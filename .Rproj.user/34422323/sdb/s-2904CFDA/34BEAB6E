{
    "contents" : "library(MASS)\nlibrary(poweRlaw)\nlibrary(actuar)\nlibrary(reshape2)\nlibrary(penalized)\n\ntransformation.matrix <- function(network.1, network.2, by.tfs=T, standardize=T, remove.diagonal=T, method=\"ols\"){\n    if(is.list(network.1)&&is.list(network.2)){\n        if(by.tfs){\n            net1 <- t(network.1$reg.net)\n            net2 <- t(network.2$reg.net)\n        } else {\n            net1 <- network.1$reg.net\n            net2 <- network.2$reg.net\n        }\n    } else if(is.matrix(network.1)&&is.matrix(network.2)){\n        if(by.tfs){\n            net1 <- t(network.1)\n            net2 <- t(network.2)\n        } else {\n            net1 <- network.1\n            net2 <- network.2\n        }\n    } else {\n        stop(\"Networks must be lists or matrices\")\n    }\n    #gene.trans.matrix <- svd(net2)$v %*% diag(1/svd(net2)$d) %*% t(svd(net2)$u) %*% net1\n    if (method == \"kabsch\"){\n        tf.trans.matrix <- kabsch(net1,net2)\n    }\n    if (method == \"old\"){\n        svd.net2 <- svd(net2)\n        tf.trans.matrix <- svd.net2$v %*% diag(1/svd.net2$d) %*% t(svd.net2$u) %*% net1\n    }\n    if (method == \"ols\"){\n        tf.trans.matrix <- ginv(t(net1)%*%net1)%*%t(net1)%*%net2\n        print(\"Using OLS method\")\n    }\n    if (standardize){\n        tf.trans.matrix <- apply(tf.trans.matrix, 1, function(x){\n            #   x.zero <- (x-mean(x))\n            x/sum(abs(x))\n        })\n    }\n    \n    if (remove.diagonal){\n        diag(tf.trans.matrix) <- 0\n    }\n    # Add column labels\n    colnames(tf.trans.matrix) <- rownames(tf.trans.matrix)\n    tf.trans.matrix\n}\nbereFull <- function(motifs, exprData, alpha=.5, penalized=T, lambda=10, score=\"motifincluded\"){\n    require(MASS)\n    exprData <- data.frame(exprData)\n    tfdcast <- dcast(motifs,V1~V2,fill=0)\n    rownames(tfdcast) <- tfdcast[,1]\n    tfdcast <- tfdcast[,-1]\n    \n    exprData <- exprData[sort(rownames(exprData)),]\n    tfdcast <- tfdcast[,sort(colnames(tfdcast)),]\n    tfNames <- rownames(tfdcast)[rownames(tfdcast) %in% rownames(exprData)]\n    \n    ## Filtering\n    # filter out the TFs that are not in expression set\n    tfdcast <- tfdcast[rownames(tfdcast)%in%tfNames,]\n    \n    # check that IDs match\n    if (prod(rownames(exprData)==colnames(tfdcast))!=1){stop(\"ID mismatch\")}\n    \n    ## Get direct evidence\n    directCor <- t(cor(t(exprData),t(exprData[rownames(exprData)%in%tfNames,]))^2)\n    \n    ## Get the indirect evidence    \n    result <- t(apply(tfdcast, 1, function(x){\n        cat(\".\")\n        tfTargets <- as.numeric(x)\n        \n        # Ordinary Logistic Reg\n        #         z <- glm(tfTargets ~ ., data=exprData, family=\"binomial\")\n        \n        # Penalized Logistic Reg\n        z <- penalized(tfTargets, exprData, lambda2=lambda, model=\"logistic\", standardize=T)\n        #         z <- optL1(tfTargets, exprData, minlambda1=25, fold=5)\n        \n        \n        predict(z, exprData)\n    }))\n    \n    ## Convert values to ranks\n    directCor <- matrix(rank(directCor), ncol=ncol(directCor))\n    result <- matrix(rank(result), ncol=ncol(result))\n    \n    consensus <- directCor*(1-alpha) + result*alpha\n    rownames(consensus) <- rownames(tfdcast)\n    colnames(consensus) <- rownames(exprData)\n    #     if(score==\"motifincluded\"){\n    #         consensus <- as.matrix(result + tfdcast)\n    #     }\n    consensus\n}\n\n\n\nnumTFs <- 50\nnumGenes <- 1000\nnumSamples <- 500\nnumTransitions <- 5\n\ndegrees <- floor(rpareto(numTFs,20,10000))\ndegrees[degrees<10] <- 10\ndegrees[degrees>(numGenes/4)] <- numGenes/4\nadjMat <- sapply(degrees,function(x){\n  sample(c(rep(1,x),rep(0,numGenes-x)))\n})\nselectedTFs <- sample(1:numTFs,numTransitions)\nrownames(adjMat) <- paste(\"GENE\",1:numGenes,sep=\"\")\ncolnames(adjMat) <- paste(\"TF\",1:numTFs,sep=\"\")\nrownames(adjMat)[1:numTFs]<- colnames(adjMat)[1:numTFs]\n\n# Included edges\nadjMat[selectedTFs,selectedTFs]<- 1\nSigma <- adjMat%*%t(adjMat)\ndiag(Sigma) <- diag(Sigma)+2\nexprData1 <- t(mvrnorm(numSamples, mu=rep(0,numGenes), Sigma=Sigma))\nrownames(exprData1)<- rownames(adjMat)\n\n# Excluded edges\nadjMat[selectedTFs,selectedTFs] <- 0\nSigma <- adjMat%*%t(adjMat)\ndiag(Sigma) <- diag(Sigma)+10\nexprData2 <- t(mvrnorm(numSamples, mu=rep(0,numGenes), Sigma=Sigma))\nrownames(exprData2)<- rownames(adjMat)\n\n# set motif prior adjMat\nadjMat[selectedTFs,selectedTFs]<-rbinom(numTransitions^2,1,.5)\nadjMat <- data.frame(adjMat)\nadjMat$id <- rownames(adjMat)\nadjMatMelt <- melt(adjMat, \"id\")[,c(2,1,3)]\ncolnames(adjMatMelt)<-c(\"V1\",\"V2\",\"V3\") \n\nbereScores1 <- bereFull(adjMatMelt, exprData1)\nbereScores2 <- bereFull(adjMatMelt, exprData2)\n\ntm <- transformation.matrix(bereScores1, bereScores2, remove.diagonal=T, method=\"ols\")\n\nexprData <- cbind(exprData1,exprData2)\n\nnull.tms <- replicate(1000,{\n  partition <- sample(1:(2*numSamples))\n  nullbereScores1 <- bereFull(adjMatMelt, exprData[,partition[1:numSamples]])\n  nullbereScores2 <- bereFull(adjMatMelt, exprData[,partition[(numSamples+1):(numSamples*2)]])\n  transformation.matrix(nullbereScores1, nullbereScores2, remove.diagonal=T, method=\"ols\")\n})\nnull.tms.list <- lapply(seq(dim(null.tms)[3]), function(x) null.tms[ , , x])\n\nssodm.plot(tm, null.tms.list, plot.title=\"Simulated Data: dTFI\")\nssodm.plot(tm, null.tms.list, rescale=T, plot.title=\"SSODM observed and null, COPD subjects vs Smoker control (R)\")\nssodm.plot(tm, null.tms.list, rescale=T, plot.title=\"SSODM observed and null, COPD subjects vs Smoker control (R)\", \n           highlight.tfs = rownames(exprData2)[selectedTFs])\n\nsave.image(file=\"sim_network_TM\")",
    "created" : 1438011286626.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1448588586",
    "id" : "34BEAB6E",
    "lastKnownWriteTime" : 1438106775,
    "path" : "~/gd/Harvard/Research/R_workspace/sim_network_transition.R",
    "project_path" : "sim_network_transition.R",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "source_on_save" : false,
    "type" : "r_source"
}