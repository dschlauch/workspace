{
    "contents" : "library(penalized)\nlibrary(reshape2)\nlibrary(tidyr)\n# library(pandaR)\n# library(bptools)\ncopd.filename <- \"null.networks_all.rds\"\neclipse.filename <- \"eclipse.networks.rds\"\nlocal.wd <- \"~/gd/Harvard/Research/\"\ndata.dir  <- \"./data/Eclipse/\"\nsetwd(local.wd)\nsetwd(data.dir)\n\ntransformation.matrix <- function(network.1, network.2, by.tfs=T, standardize=T, remove.diagonal=T, method=\"ols\"){\n  if(is.list(network.1)&&is.list(network.2)){\n    if(by.tfs){\n      net1 <- t(network.1$reg.net)\n      net2 <- t(network.2$reg.net)\n    } else {\n      net1 <- network.1$reg.net\n      net2 <- network.2$reg.net\n    }\n  } else if(is.matrix(network.1)&&is.matrix(network.2)){\n    if(by.tfs){\n      net1 <- t(network.1)\n      net2 <- t(network.2)\n    } else {\n      net1 <- network.1\n      net2 <- network.2\n    }\n  } else {\n    stop(\"Networks must be lists or matrices\")\n  }\n  #gene.trans.matrix <- svd(net2)$v %*% diag(1/svd(net2)$d) %*% t(svd(net2)$u) %*% net1\n  if (method == \"kabsch\"){\n    tf.trans.matrix <- kabsch(net1,net2)\n  }\n  if (method == \"old\"){\n    svd.net2 <- svd(net2)\n    tf.trans.matrix <- svd.net2$v %*% diag(1/svd.net2$d) %*% t(svd.net2$u) %*% net1\n  }\n  if (method == \"ols\"){\n    tf.trans.matrix <- ginv(t(net1)%*%net1)%*%t(net1)%*%net2\n    print(\"Using OLS method\")\n  }\n  if (standardize){\n    tf.trans.matrix <- apply(tf.trans.matrix, 1, function(x){\n      #   x.zero <- (x-mean(x))\n      x/sum(abs(x))\n    })\n  }\n  \n  if (remove.diagonal){\n    diag(tf.trans.matrix) <- 0\n  }\n  # Add column labels\n  colnames(tf.trans.matrix) <- rownames(tf.trans.matrix)\n  tf.trans.matrix\n}\nbereFull <- function(motifs, exprData, alpha=.5, penalized=T, lambda=10, score=\"motifincluded\"){\n  require(MASS)\n  exprData <- data.frame(exprData)\n  tfdcast <- dcast(motifs,V1~V2,fill=0)\n  rownames(tfdcast) <- tfdcast[,1]\n  tfdcast <- tfdcast[,-1]\n  \n  exprData <- exprData[sort(rownames(exprData)),]\n  tfdcast <- tfdcast[,sort(colnames(tfdcast)),]\n  tfNames <- rownames(tfdcast)[rownames(tfdcast) %in% rownames(exprData)]\n  \n  ## Filtering\n  # filter out the TFs that are not in expression set\n  tfdcast <- tfdcast[rownames(tfdcast)%in%tfNames,]\n  \n  # check that IDs match\n  if (prod(rownames(exprData)==colnames(tfdcast))!=1){stop(\"ID mismatch\")}\n  \n  ## Get direct evidence\n  directCor <- t(cor(t(exprData),t(exprData[rownames(exprData)%in%tfNames,]))^2)\n  \n  ## Get the indirect evidence    \n  result <- t(apply(tfdcast, 1, function(x){\n    cat(\".\")\n    tfTargets <- as.numeric(x)\n    \n    # Ordinary Logistic Reg\n    #         z <- glm(tfTargets ~ ., data=exprData, family=\"binomial\")\n    \n    # Penalized Logistic Reg\n    z <- penalized(tfTargets, exprData, lambda2=lambda, model=\"logistic\", standardize=T)\n    #         z <- optL1(tfTargets, exprData, minlambda1=25, fold=5)\n    \n    \n    predict(z, exprData)\n  }))\n  \n  ## Convert values to ranks\n  directCor <- matrix(rank(directCor), ncol=ncol(directCor))\n  result <- matrix(rank(result), ncol=ncol(result))\n  \n  consensus <- directCor*(1-alpha) + result*alpha\n  rownames(consensus) <- rownames(tfdcast)\n  colnames(consensus) <- rownames(exprData)\n  #     if(score==\"motifincluded\"){\n  #         consensus <- as.matrix(result + tfdcast)\n  #     }\n  consensus\n}\n\n\n\n######################################################\n##      Data Loading from ECLIPSE dataset          ###\n##                                                 ###\n######################################################\neclipse <- list()\neclipse$motif    <- read.table(\"ECLIPSE_Blood_Motif.txt\",header=F)\neclipse$exp      <- read.table(\"ECLIPSE_Blood_Exp.txt\",row.names=1,header=T)\neclipse$ppi      <- read.table(\"OV_PPI.txt\",header=F)\neclipse$clinical <- read.table(\"ECLIPSE_blood.txt\",header=T,fill = TRUE, sep=\"\\t\",row.names=1)\neclipse$exp      <- eclipse$exp[,order(colnames(eclipse$exp))]  # Make sure expression and clinical is in same order\neclipse$clinical <- eclipse$clinical[colnames(eclipse$exp),]    # Make sure clinical only contains patients with expression data\n\n# Specify the group partition\nfilter.vec.1 <- eclipse$clinical$Subject.type==\"COPD Subjects\"\nfilter.vec.2 <- eclipse$clinical$Subject.type==\"Smoker Controls\"\n\npermutations <- 10\nresMatrix <- matrix(NA, nrow=permutations*4, ncol=164)\nnullMatrix <- matrix(NA, nrow=permutations*2, ncol=164)\nhetMatrix <- matrix(NA, nrow=permutations*2, ncol=164)\nfor (i in 0:(permutations-1)){\n  print(\"********************** iteration ***********************\")\n  print(i)\n  sampleSize <- 40\n  homosubset1 <- sample(which(filter.vec.1),sampleSize*2)\n  net1 <- bereFull(eclipse$motif,eclipse$exp[,homosubset1[1:sampleSize]])\n  net2 <- bereFull(eclipse$motif,eclipse$exp[,homosubset1[(sampleSize+1):(sampleSize*2)]])\n  homosubset2 <- sample(which(filter.vec.2),sampleSize*2)\n  net3 <- bereFull(eclipse$motif,eclipse$exp[,homosubset2[1:sampleSize]])\n  net4 <- bereFull(eclipse$motif,eclipse$exp[,homosubset2[(sampleSize+1):(sampleSize*2)]])\n  hetsubset <- sample(c(homosubset1,homosubset2))\n  net5 <- bereFull(eclipse$motif,eclipse$exp[,hetsubset[1:sampleSize]])\n  net6 <- bereFull(eclipse$motif,eclipse$exp[,hetsubset[(sampleSize+1):(sampleSize*2)]])\n  net7 <- bereFull(eclipse$motif,eclipse$exp[,hetsubset[(2*sampleSize+1):(sampleSize*3)]])\n  net8 <- bereFull(eclipse$motif,eclipse$exp[,hetsubset[(3*sampleSize+1):(sampleSize*4)]])\n  \n  \n  tm <- transformation.matrix(net1, net3, remove.diagonal=T, method=\"ols\")\n  resMatrix[i*4+1,] <- apply(tm,2,function(x){t(x)%*%x})\n  tm <- transformation.matrix(net1, net4, remove.diagonal=T, method=\"ols\")\n  resMatrix[i*4+2,] <- apply(tm,2,function(x){t(x)%*%x})\n  tm <- transformation.matrix(net2, net3, remove.diagonal=T, method=\"ols\")\n  resMatrix[i*4+3,] <- apply(tm,2,function(x){t(x)%*%x})\n  tm <- transformation.matrix(net2, net4, remove.diagonal=T, method=\"ols\")\n  resMatrix[i*4+4,] <- apply(tm,2,function(x){t(x)%*%x})\n  \n  tm <- transformation.matrix(net1, net2, remove.diagonal=T, method=\"ols\")\n  nullMatrix[i*2+1,] <- apply(tm,2,function(x){t(x)%*%x})\n  tm <- transformation.matrix(net3, net4, remove.diagonal=T, method=\"ols\")\n  nullMatrix[i*2+2,] <- apply(tm,2,function(x){t(x)%*%x})\n  \n  tm <- transformation.matrix(net5, net6, remove.diagonal=T, method=\"ols\")\n  hetMatrix[i*2+1,] <- apply(tm,2,function(x){t(x)%*%x})\n  tm <- transformation.matrix(net7, net8, remove.diagonal=T, method=\"ols\")\n  hetMatrix[i*2+2,] <- apply(tm,2,function(x){t(x)%*%x})\n  \n}\n\nsaveRDS(list(resMatrix=resMatrix,nullMatrix=nullMatrix,hetMatrix=hetMatrix), \"./homogeneity_results.rds\")\n\n# transcriptionFactor <- \"E2F3\"\n# values <- c(resMatrix[,transcriptionFactor], nullMatrix[,transcriptionFactor])\n# xvalues <- c(rep(\"obs\",length(resMatrix[,transcriptionFactor])), rep(\"null\",length(nullMatrix[,transcriptionFactor])))\n# qplot(y=values,x=xvalues, geom = \"boxplot\", main=paste(\"Observed vs Null for\",transcriptionFactor))\n\nresValues <- sort(c(resMatrix[,3])[c(F,T)])\nhomValues <- sort(c(nullMatrix[,3]))\n\n\npvalsObsVsHet <- sapply(1:ncol(resMatrix), function(i){\n  tt <- t.test(resMatrix[,i],hetMatrix[,i])\n  tt$p.value\n})\npvalsHomVsHet <- sapply(1:ncol(nullMatrix), function(i){\n  tt <- t.test(nullMatrix[,i],hetMatrix[,i])\n  tt$p.value\n})\n\npvalsHomSMC <- sapply(seq(2,ncol(nullMatrix),2), function(i){\n  tt <- t.test(nullMatrix[,i],hetMatrix[,i])\n  tt$p.value\n})\npvalsHomCOPD <- sapply(seq(1,ncol(nullMatrix),2), function(i){\n  tt <- t.test(nullMatrix[,i],hetMatrix[,i])\n  tt$p.value\n})\nlibrary(gridExtra)\nplot1 <- qplot(pvalsObsVsHet, binwidth=.04, main=\"p-value plot for t-test of dTFIs of observed vs null\")\nplot2 <- qplot(pvalsHomVsHet, binwidth=.04, main=\"p-value plot for t-test of dTFIs of homogenous vs null\")\ngrid.arrange(plot1, plot2, ncol=2)\nplot1 <- qplot(pvalsHomCOPD, binwidth=.04, main=\"COPD null\")\nplot2 <- qplot(pvalsHomSMC, binwidth=.04, main=\"Smoker Control null\")\ngrid.arrange(plot1, plot2, ncol=2)\nqplot(sort(pvalsHomCOPD), sort(pvalsHomSMC), main=\"QQ plot: COPD vs SMC (all null)\")+ geom_abline(intercept = 0, slope = 1)\n\nprint(qplot(y=resValues, x=homValues, main=paste(\"QQ plot, homogenous networks vs hetergenous networks (all null)\"))+ geom_abline(intercept = 0, slope = 1))\n\nhomValues <- sort(c(nullMatrix[,3])[c(F,T)])\nhetValues <- sort(c(hetMatrix[,3]))\n\nprint(qplot(y=hetValues, x=homValues, main=paste(\"QQ plot, homogenous networks vs hetergenous networks (all null)\"))+ geom_abline(intercept = 0, slope = 1))\n\nqplot(colMeans(hetMatrix) - colMeans(nullMatrix))\nqplot(colMeans(resMatrix) - colMeans(hetMatrix))\n\n\npng(filename=\"./homogeneityQQ.png\")\nprint(qplot(y=hetValues, x=homValues, main=paste(\"QQ plot, homogenous networks vs hetergenous networks (all null)\"))+ geom_abline(intercept = 0, slope = 1))\ndev.off()\n",
    "created" : 1437673387535.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2676313094",
    "id" : "8C70BFCC",
    "lastKnownWriteTime" : 1438036929,
    "path" : "~/gd/Harvard/Research/R_workspace/homogeneity_assessment.R",
    "project_path" : "homogeneity_assessment.R",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "source_on_save" : false,
    "type" : "r_source"
}