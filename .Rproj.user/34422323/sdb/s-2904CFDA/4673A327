{
    "contents" : "#' Bipartite Edge Reconstruction from Expression data\n#'\n#' This function generates a complete bipartite network from gene expression data and sequence motif data \n#' \n#' @param motif A motif dataset, a data.frame, matrix or exprSet containing 3 columns. Each row describes an motif associated with a transcription factor (column 1) a gene (column 2) and a score (column 3) for the motif.\n#' @param expr An expression dataset, as a genes (rows) by samples (columns) data.frame\n#' @param verbose logical to indicate printing of output for algorithm progress.\n#' @param method String to indicate algorithm method.  Must be one of \"cd\",\"lda\", or \"wcd\". Default is correlation difference \"cd\".\n#' @param score String to indicate whether motif information will be readded upon completion of the algorithm\n#' @param cpp logical use C++ for maximum speed, set to false if unable to run.\n#' @keywords keywords\n#' @export\n#' @return TBD, An object of class \"bere\" (currently matrix or data.frame) \n#' @examples\n#' data(yeast)\nbere <- function(motif.data, \n                      expr.data,\n                      verbose=F,\n                      randomize=\"none\",\n                      method=\"cd\",\n                      score=\"motifincluded\",\n                      cpp=F){\n  if(verbose)\n    print('Initializing and validating')\n  # Create vectors for TF names and Gene names from Motif dataset\n  tf.names   <- sort(unique(motif.data[,1]))\n  num.TFs    <- length(tf.names)\n  if (is.null(expr.data)){\n    stop(\"Error: Expression data null\")\n  } else {\n    # Use the motif data AND the expr data (if provided) for the gene list\n    gene.names <- sort(intersect(motif.data[,2],rownames(expr.data)))\n    num.genes  <- length(gene.names)\n    \n    # Filter out the expr genes without motif data\n    expr.data <- expr.data[rownames(expr.data) %in% gene.names,]\n    \n    # Keep everything sorted alphabetically\n    expr.data      <- expr.data[order(rownames(expr.data)),]\n    num.conditions <- ncol(expr.data);\n    if (randomize=='within.gene'){\n      expr.data <- t(apply(expr.data, 1, sample))\n      if(verbose)\n        print(\"Randomizing by reordering each gene's expression\")\n    } else if (randomize=='by.genes'){\n      rownames(expr.data) <- sample(rownames(expr.data))\n      expr.data           <- expr.data[order(rownames(expr.data)),]\n      if(verbose)\n        print(\"Randomizing by reordering each gene labels\")\n    }\n  }\n  \n  # Bad data checking\n  if (num.genes==0){\n    stop(\"Error validating data.  No matched genes.\\n  Please ensure that gene names in expression file match gene names in motif file.\")\n  }\n  \n  strt<-Sys.time()\n  if(num.conditions==0) {\n    stop(\"Error: Number of samples = 0\")\n    gene.coreg <- diag(num.genes)\n  } else if(num.conditions<3) {\n    stop('Not enough expression conditions detected to calculate correlation.')\n  } else {\n    if(verbose)\n      print('Verified adequate samples, calculating correlation matrix')\n    if(cpp){\n      # C++ implementation\n      gene.coreg <- rcpp_ccorr(t(apply(expr.data, 1, function(x)(x-mean(x))/(sd(x)))))\n      rownames(gene.coreg)<- rownames(expr.data)\n      colnames(gene.coreg)<- rownames(expr.data)\n      \n    } else {\n      # Standard r correlation calculation\n      gene.coreg <- cor(t(expr.data), method=\"pearson\", use=\"pairwise.complete.obs\")\n    }\n  }\n  \n  print(Sys.time()-strt)\n  \n  if(verbose)\n    print('More data cleaning')\n  # Convert 3 column format to matrix format\n  colnames(motif.data) <- c('TF','GENE','value')\n  regulatory.network <- tidyr::spread(motif.data, GENE, value, fill=0)\n  rownames(regulatory.network) <- regulatory.network[,1]\n  # sort the TFs (rows), and remove redundant first column\n  regulatory.network <- regulatory.network[order(rownames(regulatory.network)),-1]\n  # sort the genes (columns)\n  regulatory.network <- as.matrix(regulatory.network[,order(colnames(regulatory.network))])\n  \n  # Filter out any motifs that are not in expr dataset (if given)\n  if (!is.null(expr.data)){\n    regulatory.network <- regulatory.network[,colnames(regulatory.network) %in% gene.names]\n  }\n  \n  # store initial motif network (alphabetized for rows and columns)\n  #   starting.motifs <- regulatory.network\n  \n\n  if(verbose)\n    print('Main calculation')\n  ########################################\n\n  strt<-Sys.time()\n  correlation.dif <- sweep(regulatory.network,1,rowSums(regulatory.network),`/`)%*%gene.coreg-sweep(1-regulatory.network,1,rowSums(1-regulatory.network),`/`)%*%gene.coreg\n  result <- sweep(correlation.dif, 2, apply(correlation.dif, 2, sd),'/')\n  #   regulatory.network <- ifelse(res>quantile(res,1-mean(regulatory.network)),1,0)\n  \n  print(Sys.time()-strt)\n  ########################################\n  if(score==\"motifincluded\"){\n    result <- result + max(result)*regulatory.network\n  }\n  result\n}\n#' Bipartite Edge Reconstruction from Expression data (LDA method)\n#'\n#' This function generates a complete bipartite network from gene expression data and sequence motif data \n#' \n#' @param motif A motif dataset, a data.frame, matrix or exprSet containing 3 columns. Each row describes an motif associated with a transcription factor (column 1) a gene (column 2) and a score (column 3) for the motif.\n#' @param expr An expression dataset, as a genes (rows) by samples (columns) data.frame\n#' @param verbose logical to indicate printing of output for algorithm progress.\n#' @param method String to indicate algorithm method.  Must be one of \"cd\",\"lda\", or \"wcd\". Default is correlation difference \"cd\".\n#' @param score String to indicate whether motif information will be readded upon completion of the algorithm\n#' @keywords keywords\n#' @export\n#' @return TBD, An object of class \"bere\" (currently matrix or data.frame) \n#' @examples\n#' 1+1\nldaBERE <- function(motifs, expData, score=\"motifincluded\"){\n  require(MASS)\n  expData <- data.frame(expData)\n  tfdcast <- dcast(motifs,V1~V2,fill=0)\n  rownames(tfdcast) <- tfdcast[,1]\n  tfdcast <- tfdcast[,-1]\n  \n  expData <- expData[sort(rownames(expData)),]\n  tfdcast <- tfdcast[,sort(colnames(tfdcast)),]\n  # check that IDs match\n  if (prod(rownames(expData)==colnames(tfdcast))!=1){stop(\"ID mismatch\")}\n  result <- t(apply(tfdcast, 1, function(x){\n    cat(\".\")\n    tfTargets <- as.numeric(x)\n    z <- lda(tfTargets ~ ., expData)\n    #     ldaRes <- cbind(predict(z, expData)$class, predict(z, expData)$posterior,tf1)\n    predict(z, expData)$posterior[,2]\n  }))\n  \n  if(score==\"motifincluded\"){\n    result <- as.matrix(result + tfdcast)\n  }\n  result\n}\n\n#' Bipartite Edge Reconstruction from Expression data (composite method with direct/indirect)\n#'\n#' This function generates a complete bipartite network from gene expression data and sequence motif data \n#' \n#' @param motif A motif dataset, a data.frame, matrix or exprSet containing 3 columns. Each row describes an motif associated with a transcription factor (column 1) a gene (column 2) and a score (column 3) for the motif.\n#' @param expr An expression dataset, as a genes (rows) by samples (columns) data.frame\n#' @param alpha A weight parameter specifying proportion of weight to give to indirect compared to direct evidence.  See documentation.\n#' @param verbose logical to indicate printing of output for algorithm progress.\n#' @param method String to indicate algorithm method.  Must be one of \"cd\",\"lda\", or \"wcd\". Default is correlation difference \"cd\".\n#' @param score String to indicate whether motif information will be readded upon completion of the algorithm\n#' @keywords keywords\n#' @export\n#' @return TBD, An object of class \"bere\" (currently matrix or data.frame) \n#' @examples\n#' 1+1\nbereFull <- function(motifs, exprData, alpha=.5, penalized=T, lambda=10, score=\"motifincluded\"){\n    require(MASS)\n    exprData <- data.frame(exprData)\n    tfdcast <- dcast(motifs,V1~V2,fill=0)\n    rownames(tfdcast) <- tfdcast[,1]\n    tfdcast <- tfdcast[,-1]\n    \n    exprData <- exprData[sort(rownames(exprData)),]\n    tfdcast <- tfdcast[,sort(colnames(tfdcast)),]\n    tfNames <- rownames(tfdcast)[rownames(tfdcast) %in% rownames(exprData)]\n    \n    ## Filtering\n    # filter out the TFs that are not in expression set\n    tfdcast <- tfdcast[rownames(tfdcast)%in%tfNames,]\n    \n    # Filter out genes that aren't targetted by anything 7/28/15\n    commonGenes <- intersect(colnames(tfdcast),rownames(exprData))\n    exprData <- exprData[commonGenes,]\n    tfdcast <- tfdcast[,commonGenes]\n    \n    # check that IDs match\n    if (prod(rownames(exprData)==colnames(tfdcast))!=1){stop(\"ID mismatch\")}\n\n    ## Get direct evidence\n    directCor <- t(cor(t(exprData),t(exprData[rownames(exprData)%in%tfNames,]))^2)\n    \n    ## Get the indirect evidence    \n    result <- t(apply(tfdcast, 1, function(x){\n        cat(\".\")\n        tfTargets <- as.numeric(x)\n        \n        # Ordinary Logistic Reg\n#         z <- glm(tfTargets ~ ., data=exprData, family=\"binomial\")\n        \n        # Penalized Logistic Reg\n        z <- penalized(tfTargets, exprData, lambda2=lambda, model=\"logistic\", standardize=T)\n#         z <- optL1(tfTargets, exprData, minlambda1=25, fold=5)\n        \n        \n        predict(z, exprData)\n    }))\n    \n    ## Convert values to ranks\n    directCor <- matrix(rank(directCor), ncol=ncol(directCor))\n    result <- matrix(rank(result), ncol=ncol(result))\n    \n    consensus <- directCor*(1-alpha) + result*alpha\n    rownames(consensus) <- rownames(tfdcast)\n    colnames(consensus) <- rownames(exprData)\n    consensusRange <- max(consensus)- min(consensus)\n    if(score==\"motifincluded\"){\n        consensus <- as.matrix(consensus + consensusRange*tfdcast)\n    }\n    consensus\n}\n\n#' function for building a network based only on node degree\n#'\n#' This function creates an unsophisticated graph based solely on the node degrees\n#' \n#' @param motif A motif dataset, a data.frame, matrix or exprSet containing 3 columns. Each row describes an motif associated with a transcription factor (column 1) a gene (column 2) and a score (column 3) for the motif.\n#' @keywords keywords\n#' @export\n#' @return network \n#' @examples\n#' 1+1\ndegreeApproach <- function(motifs){\n    tfDegree <- table(motifs[,c(1,3)])\n    geneDegree <- table(motifs[,c(2,3)])\n    \n    tfMatrix <- matrix(rep(tfDegree[,2],nrow(geneDegree)), ncol=nrow(geneDegree))\n    geneMatrix <- t(matrix(rep(geneDegree[,2],nrow(tfDegree)), nrow=nrow(geneDegree)))\n    \n    result <- tfMatrix+geneMatrix\n    rownames(result) <- rownames(tfDegree)\n    colnames(result) <- rownames(geneDegree)\n    result\n}",
    "created" : 1437671275611.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1655748165",
    "id" : "4673A327",
    "lastKnownWriteTime" : 1438198252,
    "path" : "~/gd/Harvard/Research/R_Packages/bereR/R/regpredict.R",
    "project_path" : null,
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}