{
    "contents" : "# Example transition\nP <- matrix(c(1,1,1,0,0,0,0,0,0, 0,1,1,1,1,0,0,0,0, 0,0,0,0,1,1,1,0,0,\n                 0,0,0,0,0,0,1,1,1, 0,0,0,0,0,0,0,1,1),nrow=9)\nQ <- matrix(c(1,1,1,0,0,0,0,0,0, 0,1,1,1,1,0,0,0,0, 0,0,0,0,1,1,1,0,0,\n                 0,0,0,0,1,1,1,0,0, 0,0,0,0,0,0,0,1,1),nrow=9)\nP\nQ\nW.kabsch <- kabsch(P,Q)\nW.old <- transformation.matrix(P,Q,by.tfs=F,remove.diagonal=F,method=\"old\")\n\ncrossprod(c(P%*%W.kabsch - Q))\ncrossprod(c(P%*%W.old - Q))\n\nP<- matrix(rnorm(24),nrow=6)\nQ<- matrix(rnorm(24),nrow=6)\n\nQ<- t(apply(matrix(rnorm(16),nrow=4),1,function(x){\n  x-mean(x)\n}))\n\nQ<- scale(matrix(rnorm(8),nrow=2))\nW.kabsch <- kabsch(P,Q)\nW.old    <- transformation.matrix(P,Q,remove.diagonal=F,by.tfs=F,method='old')\nW.solve  <- solve(P,Q)\nQ.est.k <- P%*%W.kabsch\nQ.est.o <- P%*%W.old\nround(P,3)\nround(Q,3)\n\nplot(P,Q%*%W.kabsch)\nplot(Q,P%*%W.kabsch)\nplot(W.kabsch%*%P,Q)\nplot(W.kabsch%*%Q,P)\nplot(P%*%W.solve,Q)\n\nplot(P,Q%*%W.old)\nplot(Q,P%*%W.old)\nplot(W.old%*%P,Q)\nplot(W.old%*%Q,P)\nsummary(lm(c(Q)~c(Q.est.k)))\n\ntransformation.matrix(diag(5),A,remove.diagonal=F)\nkabsch(A,B) %*% B\n\n# http://en.wikipedia.org/wiki/Kabsch_algorithm\n# http://math.stackexchange.com/questions/77462/finding-transformation-matrix-between-two-2d-coordinate-frames-pixel-plane-to-w\n\nkabsch <- function(P,Q){\n#   P <- scale(P)\n#   Q <- scale(Q)\n  covmat <- t(Q) %*% P\n  num.TFs <- ncol(covmat)\n  svd.res <- svd(covmat)\n  \n  # Note the scalar multiplier in the middle.\n  # NOT A MISTAKE!\n  c.k <- colSums(P %*% svd.res$v * Q %*% svd.res$u)\n  \n  E <- diag(num.TFs)\n  \n  W <- svd.res$v %*% E %*% t(svd.res$u)\n  W\n}\n\nrot <- function(P,Q){\n  print(paste(sep=\"\",\"nrow=\",nrow(P),\", ncol=\",ncol(P)))\n  covmat<-cov(t(P),t(Q))\n  P%*%t(Q)\n  svd(covmat)\n  svd(P%*%t(Q))\n  E<- diag(svd(covmat)$d)\n  R <- svd(covmat)$v%*%E%*%t(svd(covmat)$u)\n  plot(R%*%P,Q)\n  plot(t(P))\n  points(t(R%*%P),pch=\"x\")\n  summary(lm(c(Q)~c(R%*%P)))\n}\neuclid <- function(A,B){\n  sum(apply(A - B,1,function(x){\n    x%*%x\n  }))\n}\n\nrot(P,Q)\n\na<-matrix(rnorm(16),nrow=4)\na <- t(a)%*%a\na.eig <- eigen(a)\na.sqrt <- a.eig$vectors %*% diag(sqrt(a.eig$values)) %*% solve(a.eig$vectors)\n\ntransMat <- function(P,Q){\n  P <- apply(P,2,function(x){\n    x - mean(x)\n  })\n  Q <- apply(Q,2,function(x){\n    x - mean(x)\n  })\n  A <- t(P) %*% Q\n  A <- cov(P,Q)\n  a.eigen <- eigen(t(A)%*%A)\n  a.sqrt <- a.eigen$vectors %*% diag(sqrt(a.eigen$values)) %*% solve(a.eigen$vectors)\n  U <- a.sqrt %*% solve(A)\n  U\n}\nP\nQ\nU <- transMat(P,Q)\nt(U%*%t(P))\n\n\n\n\nlibrary(ggplot2)\nP<-matrix(c(1,2,3,1,2,3),nrow=3)\nQ<-matrix(c(1,2,3,-1,-2,-3),nrow=3)\nseed<-matrix(rnorm(100),nrow=50)\nP<-seed+matrix(rnorm(100),nrow=50)\nQ<-seed+matrix(rnorm(100),nrow=50)\nP<-matrix(c(1,2,1,2.1),nrow=2)\nQ<-matrix(c(1,2.3,-.5,-1),nrow=2)\nP<-matrix(c(rnorm(50,50),rnorm(50,25)),nrow=50)\nQ<-matrix(c(rnorm(50,25),rnorm(50,50)),nrow=50)\n\nQ.hat <- P%*%W\nQ.hat <- P%*%kabsch(P,Q)\nQ.hat <- P%*%transformation.matrix(P,Q,by.tfs=F,method='old',standardize=F,remove.diagonal=F)\nbeta.matrix <- solve(t(P)%*%P)%*%t(P)%*%Q\nQ.hat <- P%*%beta.matrix\n\nplot.transformation(P,Q,Q.hat)\n\nplot.transformation <- function(P,Q,Q.hat){\n  df <- data.frame(rbind(P,Q.hat,Q))\n  df$net <- c(rep(\"P\",nrow(P)),rep(\"Q.hat\",nrow(Q.hat)),rep(\"Q\",nrow(Q)))\n  df$tf  <- rep(1:nrow(P),3) \n  ggplot(df, aes(X1, X2, group = tf)) +   \n    geom_point(size=8,aes(color=factor(net),shape = factor(net))) +\n    geom_line() +\n    geom_text(data = df,aes(x=X1,y=X2, label=tf))\n}\n\n\nbeta.matrix\n\nnba <- read.csv(\"http://datasets.flowingdata.com/ppg2008.csv\")\nnba$Name <- with(nba, reorder(Name, PTS))\nnba.m <- melt(nba)\nnba.m <- ddply(nba.m, .(variable), transform,rescale = rescale(value))\n\nmelt.tm <- melt(lasso)\nggplot(melt.tm, aes(y=Var1,x=Var2)) + \n  geom_tile(aes(fill=value)) + \n  scale_fill_gradient(low=\"white\", high=\"darkblue\") + \n  xlab(\"\") + \n  ylab(\"\") +\n  theme(axis.text.x = element_text(angle = 90,hjust=1))\n\n\napply(tm.observed,2,)\n\n\n\nnn.adj.mat.COPD <- eclipse$COPD.network\nnn.adj.mat.COPD[nn.adj.mat.COPD<0] <-0\n\nnn.adj.mat.SmCo <- eclipse$SmCo.network\nnn.adj.mat.SmCo[nn.adj.mat.SmCo<0] <-0\n\nnn.tm <- transformation.matrix(nn.adj.mat.COPD, nn.adj.mat.SmCo,remove.diagonal=F,method=\"ols\")\nmean(nn.tm)*189\n\ntm.cor.mat <- cor(t(eclipse$COPD.network),t(eclipse$SmCo.network))\ntm.cor.mat.melt <- melt(tm.cor.mat)\n\nggplot(tm.cor.mat.melt, aes(y=Var1,x=Var2)) + \n  geom_tile(aes(fill=value)) + \n  scale_fill_gradient(low=\"white\", high=\"darkblue\") + \n  xlab(\"\") + \n  ylab(\"\") +\n  theme(axis.text.x = element_text(angle = 90,hjust=1))\n\nrank.tm.cor.mat <- apply(tm.cor.mat,2,rank)\n\nvals <- c(rnorm(50,1),rnorm(50))\ngroups <- c(rep(\"A\",50),rep(\"B\",50))\npredict(lda(groups~vals),data.frame(vals))\n\nbereLDA <- function(motif.data, \n                            expr.data,\n                            verbose=T,\n                            randomize=\"none\",\n                            cpp=T){\n  if(verbose)\n    print('Initializing and validating')\n  # Create vectors for TF names and Gene names from Motif dataset\n  tf.names   <- sort(unique(motif.data[,1]))\n  num.TFs    <- length(tf.names)\n  if (is.null(expr.data)){\n    stop(\"Error: Expression data null\")\n  } else {\n    # Use the motif data AND the expr data (if provided) for the gene list\n    gene.names <- sort(intersect(motif.data[,2],rownames(expr.data)))\n    num.genes  <- length(gene.names)\n    \n    # Filter out the expr genes without motif data\n    expr.data <- expr.data[rownames(expr.data) %in% gene.names,]\n    \n    # Keep everything sorted alphabetically\n    expr.data      <- expr.data[order(rownames(expr.data)),]\n    num.conditions <- ncol(expr.data);\n    if (randomize=='within.gene'){\n      expr.data <- t(apply(expr.data, 1, sample))\n      if(verbose)\n        print(\"Randomizing by reordering each gene's expression\")\n    } else if (randomize=='by.genes'){\n      rownames(expr.data) <- sample(rownames(expr.data))\n      expr.data           <- expr.data[order(rownames(expr.data)),]\n      if(verbose)\n        print(\"Randomizing by reordering each gene labels\")\n    }\n  }\n  \n  # Bad data checking\n  if (num.genes==0){\n    stop(\"Error validating data.  No matched genes.\\n  Please ensure that gene names in expression file match gene names in motif file.\")\n  }\n  \n  strt<-Sys.time()\n  if(num.conditions==0) {\n    stop(\"Error: Number of samples = 0\")\n    gene.coreg <- diag(num.genes)\n  } else if(num.conditions<3) {\n    stop('Not enough expression conditions detected to calculate correlation.')\n  } else {\n    if(verbose)\n      print('Verified adequate samples, calculating correlation matrix')\n    if(cpp){\n      # C++ implementation\n      gene.coreg <- rcpp_ccorr(t(apply(expr.data, 1, function(x)(x-mean(x))/(sd(x)))))\n      rownames(gene.coreg)<- rownames(expr.data)\n      colnames(gene.coreg)<- rownames(expr.data)\n      \n    } else {\n      # Standard r correlation calculation\n      gene.coreg <- cor(t(expr.data), method=\"pearson\", use=\"pairwise.complete.obs\")\n    }\n  }\n  \n  print(Sys.time()-strt)\n  \n  if(verbose)\n    print('More data cleaning')\n  # Convert 3 column format to matrix format\n  colnames(motif.data) <- c('TF','GENE','value')\n  regulatory.network <- tidyr::spread(motif.data, GENE, value, fill=0)\n  rownames(regulatory.network) <- regulatory.network[,1]\n  # sort the TFs (rows), and remove redundant first column\n  regulatory.network <- regulatory.network[order(rownames(regulatory.network)),-1]\n  # sort the genes (columns)\n  regulatory.network <- as.matrix(regulatory.network[,order(colnames(regulatory.network))])\n  \n  # Filter out any motifs that are not in expr dataset (if given)\n  if (!is.null(expr.data)){\n    regulatory.network <- regulatory.network[,colnames(regulatory.network) %in% gene.names]\n  }\n  \n  # store initial motif network (alphabetized for rows and columns)\n  #   starting.motifs <- regulatory.network\n  \n  \n  if(verbose)\n    print('Main calculation')\n  ########################################\n  \n  strt<-Sys.time()\n  result <- apply(regulatory.network,1,function(x){\n    sapply(1:nrow(gene.coreg),function(i){\n     predict(lda(x~gene.coreg[i,]),data.frame(gene.coreg[i,]))$x\n    })\n  })\n#   correlation.dif <- sweep(regulatory.network,1,rowSums(regulatory.network),`/`)%*%gene.coreg-sweep(1-regulatory.network,1,rowSums(1-regulatory.network),`/`)%*%gene.coreg\n#   result <- sweep(correlation.dif, 2, apply(correlation.dif, 2, sd),'/')\n  #   regulatory.network <- ifelse(res>quantile(res,1-mean(regulatory.network)),1,0)\n  \n  print(Sys.time()-strt)\n  ########################################\n  \n  return(result)\n}\nn<-5;m<-5\nsum(sapply(0:min(m,n), function(x){choose(m+n-2*x,n-x)*choose(m+n-x,x)}))\n\n\n##  Start of lasso for transition matrix\nlibrary(genlasso)\nlassoTM <- function(net1,net2, unpenalized=F){\n  lasso.res <- t(sapply(1:53, function(x){\n    D<-diag(53)\n    if (unpenalized){\n      D[x,x]<-0\n    }\n    coef(genlasso(net1[x,],t(net2),D=D))$beta[,6]\n  }))\n  colnames(lasso.res) <- rownames(net1)\n  rownames(lasso.res) <- rownames(net2)\n  lasso.res\n}\nOLSTM <- function(net1,net2, unpenalized=F){\n  tf.trans.matrix <- ginv(net1%*%t(net1))%*%net1%*%t(net2)\n  colnames(tf.trans.matrix) <- rownames(net1)\n  rownames(tf.trans.matrix) <- rownames(net2)\n  tf.trans.matrix\n}\n\ntm.old <- OLSTM(bere.res.cc,bere.res.ko)\n\nlibrary(ggplot2)\n\nmelt.tm.ccko.wmotif.old <- melt(transformation.matrix(bere.res.cc.wmotif,bere.res.ko.wmotif,method=\"old\",standardize=T,remove.diagonal=T))\nmelt.tm.ccko.wmotif <- melt(lassoTM(bere.res.cc.wmotif,bere.res.ko.wmotif))\nmelt.tm.ccko.wmotif.ols <- melt(OLSTM(bere.res.cc.wmotif,bere.res.ko.wmotif))\nmelt.tm.ccko <- melt(lassoTM(bere.res.cc,bere.res.ko))\nmelt.tm.ccko.ols <- melt(OLSTM(bere.res.cc,bere.res.ko))\n\nplottm(melt.tm.ccko.wmotif, title=\"Lasso TM CC vs KO, motif readded\")\nplottm(melt.tm.ccko.wmotif.ols, title=\"OLS TM CC vs KO, motif readded\")\nplottm(melt.tm.ccko.wmotif.old, title=\"SVD method TM CC vs KO, motif readded\")\n\nplottm(melt.tm.ccko, title=\"Lasso TM CC vs KO, nomotif readded\")\nplottm(melt.tm.ccko.ols, title=\"OLS TM CC vs KO, nomotif readded\")\n\nmelt.tm.COPD_SMC <- melt(tm.observed)\nplottm(melt.tm.COPD_SMC, title=\"OLS TM COPD vs SMC, nomotif readded\")\n\nplottm <- function(melt.tm,title=\"Transition Matrix\"){\n  ggplot(melt.tm, aes(y=Var1,x=Var2)) + \n    ggtitle(title) + \n    geom_tile(aes(fill=value)) + \n    scale_fill_gradient(low=\"white\", high=\"darkblue\") + \n    xlab(\"\") + \n    ylab(\"\") +\n    theme(axis.text.x = element_text(angle = 90,hjust=1,vjust=0.5))\n}\n\nplotmasses <- function(melt.tm, title=\"Mass distribution\",xmin=0,xmax=1,gausscurve=F){\n    ggplot(melt.tm, aes(value)) + \n        ggtitle(title) + \n        xlim(xmin,xmax) +\n        geom_histogram(colour=\"black\", fill=\"white\",binwidth=(xmax-xmin)/100,aes(y = ..density..)) +\n        stat_function(fun=dnorm,size=as.numeric(gausscurve), args=list(mean=mean(melt.tm$value), sd=sd(melt.tm$value)),colour = 'red')    \n}\n\nplottm(melt.tm.COPD_COPD)\nplottm(melt.tm.COPD_SMC)\n\nmelt.tm.null <- melt(tm.null)\nplottm(melt.tm.null)\n\nplotmasses(melt.tm.COPD_COPD)\nplotmasses(melt.tm.COPD_SMC)\n\nplotmasses(melt.tm.null, gausscurve=F)\nmelt.tm.null.ODM <- removeDiagonal(melt.tm.null)\nplotmasses(melt.tm.null.ODM, gausscurve=T, xmin=-.02,xmax=.02, title=\"Mass distribution for off-diagonal NULL\")\n\nmelt.tm.COPD_SMC.ODM <- melt.tm.COPD_SMC[melt.tm.COPD_SMC[,1]!=melt.tm.COPD_SMC[,2],]\nplotmasses(melt.tm.COPD_SMC.ODM, gausscurve=T, xmin=-.02,xmax=.02, title=\"Mass distribution for off-diagonal COPD vs Smoker Control\")\n\n\n#\nremoveDiagonal <- function(x){\n    x[x[,1]!=x[,2],]\n}\n\n## creating null networks for yeast\nnull.exp <- cbind(yeast$exp.ko, yeast$exp.cc)\ntm.nulls <- lapply(1:200,function(x){\n  group <- c(rep(\"A\",106),rep(\"B\",50))\n  rownames(null.exp) <- rownames(null.exp)[sample(1:nrow(null.exp))]\n  \n  null.A.wmotif <- bere(yeast$motif, null.exp[,group==\"A\"], cpp=F)\n  null.B.wmotif <- bere(yeast$motif, null.exp[,group==\"B\"], cpp=F)\n  res <- OLSTM(null.A.wmotif,null.B.wmotif)\n  diag(res)<-0  \n  res\n})\ntm.observed <- OLSTM(bere.res.cc.wmotif,bere.res.ko.wmotif)\ndiag(tm.observed) <- 0\n# Do the sum of sq ODM plot versus null\nssodm.plot(tm.observed, tm.nulls, plot.title=\"SSODM observed and null, Yeast CC vs KO\")\nssodm.plot(tm.observed, tm.nulls, rescale=T, plot.title=\"SSODM observed and null, Yeast CC vs KO\",highlight.tfs = c(\"ELK1\",\"E2F4\"))\n\ndim(yeast$ppi)\n\nppi.table <- regulatory.network\nppi.table <- cbind(ppi.table,0)\nppi.table <- rbind(ppi.table,0)\nrownames(ppi.table)[43] <- \"YPR104C\"\ncolnames(ppi.table)[43] <- \"YBL005W\"\nppi.table <- ppi.table[sort(row.names(ppi.table)),sort(colnames(ppi.table))]\nsmall.tm.observed <- tm.observed[sort(row.names(ppi.table)),sort(colnames(ppi.table))]\ndiag(ppi.table) <- 0\ndiag(small.tm.observed) <-0\n\nonlydiag <- 1-diag(43)\n\nsummary(lm(c(ppi.table) ~ c(small.tm.observed) + c(onlydiag)))\nppi.auc <- plot.roc(ppi.table, small.tm.observed, col=\"blue\", main=\"Yeast PPI predictions\")$auc\nbaselineppi.auc <- lines.roc(ppi.table, onlydiag, col=\"red\")$auc\nlegend(.6,.2,\n       c(paste(\"PPI predictions\",round(ppi.auc,4)),paste(\"Baseline (diag only) \",round(baselineppi.auc,4))),\n       lty=c(1,1,1),lwd=c(2.5,2.5,2.5),col=c(\"blue\",\"red\",\"grey\"))\n\n\n\n## Create PPI ROC curve for COPD data (4/9/15)\ncolnames(eclipse$ppi) <- colnames(melt.tm.COPD_SMC.ODM)\nppi.table <- merge(melt.tm.COPD_SMC.ODM, eclipse$ppi, by=c(\"Var1\",\"Var2\"),all.x=T)\nppi.table[is.na(ppi.table)] <- 0\nmakeROCPlot(ppi.table,\"COPD PPI predictions\")\n\nppi.table.null <- merge(melt.tm.null.ODM, eclipse$ppi, by=c(\"Var1\",\"Var2\"),all.x=T)\nppi.table.null[is.na(ppi.table.null)] <- 0\nmakeROCPlot(ppi.table.null,\"NULL PPI predictions\")\nlibrary(pROC)\nmakeROCPlot <- function(x, title=\"PPI predictions\"){\n    pVal <- t.test(x[x[,4]==1,3], x[x[,4]==0,3])$p.value\n    ppi.auc <- plot.roc(x[,4], x[,3], col=\"blue\", main=title)$auc\n    legend(.8,.1,\n           c(paste(\"ROC PPI predictions\",round(ppi.auc,4),\"; p=\",round(pVal,4))),\n           lty=c(1,1),lwd=c(2.5,2.5),col=c(\"blue\",\"grey\"))\n    \n}\n\n\n# lda\nldaExp <- data.frame(eclipse$exp)\ntfdcast <- dcast(eclipse$motif,V1~V2,fill=0)\nrownames(tfdcast) <- tfdcast[,1]\ntfdcast <- tfdcast[,-1]\n\nexpData <- eclipse$exp[sort(rownames(eclipse$exp)),]\n# check that IDs match\nif (prod(rownames(expData)==colnames(tfdcast))!=1){\n    stop(\"ID mismatch\")\n}\n\nldaBERE <- function(tfdcast,expData){\n    t(apply(tfdcast, 1, function(x){\n        cat(\".\")\n        tfTargets <- as.numeric(x)\n        z <- lda(tfTargets ~ ., expData)\n    #     ldaRes <- cbind(predict(z, expData)$class, predict(z, expData)$posterior,tf1)\n        predict(z, expData)$posterior[,2]\n    }))\n}\nldaPredictions.COPD <- ldaBERE(tfdcast, expData[,filter.vec.1])\nldaPredictions.SMC  <- ldaBERE(tfdcast, expData[,filter.vec.2])\n\nberePredictions <- bere(eclipse$motif, eclipse$exp, cpp=F, score=\"none\")\ndata <- data.frame(c(c(berePredictions),c(ldaPredictions)))\ndata$method <- c(rep(\"bere\", nrow(data)/2),rep(\"lda\", nrow(data)/2))\ncolnames(data) <- c(\"edge\",\"method\")\nggplot(data, aes(x=edge, fill=method)) + ggtitle(\"Edgeweight distribution\") +\n    geom_histogram(binwidth=.01, alpha=.5, position=\"identity\") + \n    xlim(0, 3)\n\n#################################\n# Validation of TM in DREAM data\n# 4/26/15\n#################################\n\n# Get BERE for with/out gene upregulated\n\nlibrary(bptools)\ndataset <- \"DREAM5c\"\nsource(paste(\"./\",dataset,\".R\",sep=\"\"))\n\nbereMelt_background <- bere(motifs, exprData[, -grep(\"G313\",chipFeatures$V5)], cpp=F, verbose=F)\n\nbereMelt_G313 <- bere(motifs, exprData[, grep(\"G313\",chipFeatures$V5)], cpp=F, verbose=F)\n\ntm.G313.obs <- transformation.matrix(bereMelt_background, bereMelt_G313, remove.diagonal=F,by.tfs=T)\n\n\n# Copy expression data for null network generation\nnull.exp <- exprData\ntm.G313.null <- lapply(1:200, function(iteration){\n    rownames(null.exp) <- rownames(null.exp)[sample(1:nrow(null.exp))]\n    res1 <- bere(motifs, null.exp[,-grep(\"G2388\",chipFeatures$V6)], cpp=F)\n    res2 <- bere(motifs, null.exp[,grep(\"G2388\",chipFeatures$V6)], cpp=F)\n    list(res1,res2) \n})\n\n# Calculate the transformation matrix for the null data\ntm.G313.null <- lapply(tm.G313.null, function(x){\n    transformation.matrix(x[[1]],x[[2]],method=\"ols\",remove.diagonal = F)\n})\n\n# Do the sum of sq ODM plot versus null\nssodm.plot(tm.G313.obs, tm.G313.null, plot.title=\"Gene 313 over expressed vs Not\")\nssodm.plot(tm.G313.obs, tm.G313.null, rescale=T, plot.title=\"Gene 313 over expressed vs Not\", highlight.tfs = c(\"G313\"))\n\nplottm(melt(transformation.matrix(bereMelt_background, bereMelt_G313, remove.diagonal=T,by.tfs=T)))\n\n# Networks for Kimbie's boolean\nnetForKG1 <- read.table(\"~/network_edges_1\",stringsAsFactors=F)\nnetForKG1 <- read.table(\"~/network_edges_2\",stringsAsFactors=F)\nnetForKG1 <- dcast(netForKG1,V1~V2, fill=0)\nrownames(netForKG1) <- netForKG1[,1]\nnetForKG1 <- netForKG1[,-1]\nnetForKG1 <- netForKG1[,colnames(netForKG1) %in% rownames(netForKG1)]\nfor (i in 1:114){\n    if (sum(netForKG1[,i])==0){\n        netForKG1[sample(1:114,1),i] <-1\n    }\n    if (sum(netForKG1[i,])==0){\n        netForKG1[i,sample(1:114,1)] <-1\n    }\n}\nnetForKG1 <- removeZeroRowsColumns(netForKG1)\ndim(netForKG1)\nnet.melt <- melt(as.matrix(netForKG1))\nwrite.table(net.melt, file=\"network2_fixed\", row.names = F, col.names = F, quote=F)\n\nremoveZeroRowsColumns <- function(x){\n    x <- x[,colnames(x) %in% rownames(x)]\n    x <- x[rownames(x) %in% colnames(x),]\n    x[apply(x,1,sum)>0, apply(x,2,sum)>0]\n}\n\n###### 5/9/15\n## Generating TM network\n\nrequire(igraph)\n\ntm.sigmas <- transitionPValues(tm.observed, tm.null)\ndiag(tm.sigmas) <- 0\ntm.sigmas.melt <- melt(tm.sigmas)\n\nadjMat <- tm.observed\ndiag(adjMat) <- 0\nadjMat.melt <- melt(adjMat)\n\nadj.combined <- merge(tm.sigmas.melt,adjMat.melt, by=c(\"Var1\",\"Var2\"))\n# adjMat.melt <- cbind(adjMat.melt,abs(adjMat.melt[,3])>25)\nadj.combined <- adj.combined[abs(adj.combined[,4])>.012,]\ntfNet <- graph.data.frame(adj.combined, directed=T)\nvSize <- t.values\nvSize[vSize<0] <- 0\nvSize <- sapply(vSize*3, min, 50)\n\nV(tfNet)$size <- vSize[V(tfNet)$name]\nE(tfNet)$width <- (abs(E(tfNet)$value.x)-2)*2\nE(tfNet)$color<-ifelse(E(tfNet)$value.x>0, \"blue\", \"red\")\nplot.igraph(tfNet, edge.arrow.size=1, vertex.label.cex= 1.5, vertex.label.color= \"black\",main=\"Transition: SMC -> COPD\")\nlegend(-1.7,1.3, c(\"Gained features\",\"Lost features\"), lty=c(1,1),lwd=c(2.5,2.5),col=c(\"blue\",\"red\"))\n\n## Calculate p-values for off-diagonals\ntransitionPValues <- function(tm.observed, tm.null){\n    tm.null.mean <- apply(simplify2array(tm.null), 1:2, mean)\n    tm.null.sd <- apply(simplify2array(tm.null), 1:2, sd)\n    sigmas <- (tm.observed - tm.null.mean)/tm.null.sd\n}\n\n\nplottm(melt(tm.observed), title=\"Transition matrix: COPD vs Smoker-control (SMC) observed\")\nplottm(melt(tm.null[[1]]), title=\"Transition matrix: COPD vs Smoker-control (SMC) null1\")\nplottm(melt(tm.null[[2]]), title=\"Transition matrix: COPD vs Smoker-control (SMC) null2\")\nplottm(melt(tm.null[[3]]), title=\"Transition matrix: COPD vs Smoker-control (SMC) null3\")\nplottm(melt(tm.null[[3]]), title=\"Transition matrix: COPD vs Smoker-control (SMC) null4\")\n\n\ntm.melt <- melt(tm.null[[4]])\ntm.melt[,3][abs(tm.melt[,3])<.008]<-0\nplottm(tm.melt, title=\"Transition matrix: COPD vs Smoker-control (SMC) null4\")\n\n\n### Top transition interactions\n\ntopInteractions <- tm.sigmas.melt[order(-abs(tm.sigmas.melt[,3])),]\ntopInteractions <- cbind(topInteractions,\"GL\"=ifelse(topInteractions[,3]>0,\"Gain\",\"Loss\"))\ntopInteractions <- cbind(topInteractions,\"pVal\"= 1-pnorm(abs(topInteractions[,3])))\ntopInteractions <- cbind(topInteractions, \"FDR\"=sapply(1:35721, function(x){\n    topInteractions[x,5]*35721/x\n}))\ncolnames(topInteractions) <- c(\"Var1\",\"Var2\",\"t-stat\",\"Gain/Loss\",\"p-value\",\"FDR\")\ntopInteractions <- merge(topInteractions,adjMat.melt, by=c(\"Var1\",\"Var2\"))\ntopInteractions <- topInteractions[order(topInteractions[,5]),]\ntopInteractions[1:20,]\n\n\nadj.combined <- merge(topInteractions,adjMat.melt, by=c(\"Var1\",\"Var2\"))\n\n\n## node degree only approach\ndegreeApproach <- function(motifs){\n    tfDegree <- table(motifs[,c(1,3)])\n    geneDegree <- table(motifs[,c(2,3)])\n    \n    tfMatrix <- matrix(rep(tfDegree[,2],nrow(geneDegree)), ncol=nrow(geneDegree))\n    geneMatrix <- t(matrix(rep(geneDegree[,2],nrow(tfDegree)), nrow=nrow(geneDegree)))\n    \n    result <- tfMatrix+geneMatrix\n    rownames(result) <- rownames(tfDegree)\n    colnames(result) <- rownames(geneDegree)\n    result\n}\n\n## Compare motif degree to gold standard degree\ntfMotifDegree <- table(motifs[,c(1,3)])\ntfGSDegree <- table(goldStandard[motifs[,3]==1,c(1,3)])\n\n\nqplot(tfMotifDegree[,2],tfGSDegree[,2], geom=c(\"point\", \"smooth\"), main=\"Motif priors degree vs Gold standard degree\")\n\n\n##  Homogeneity assessment\n##  Attempt to measure if dTFI values are inflated due to homogeneity of groups compared to heterogeneity of null\n\npermutations <- 3\nresMatrix <- matrix(NA, nrow=permutations*4, ncol=164)\nnullMatrix <- matrix(NA, nrow=permutations*2, ncol=164)\nhetMatrix <- matrix(NA, nrow=permutations, ncol=164)\nfor (i in 0:(permutations-1)){\n    sampleSize <- 40\n    homosubset1 <- sample(which(filter.vec.1),sampleSize*2)\n    net1 <- bereFull(eclipse$motif,eclipse$exp[,homosubset1[1:sampleSize]])\n    net2 <- bereFull(eclipse$motif,eclipse$exp[,homosubset1[(sampleSize+1):(sampleSize*2)]])\n    homosubset2 <- sample(which(filter.vec.2),sampleSize*2)\n    net3 <- bereFull(eclipse$motif,eclipse$exp[,homosubset2[1:sampleSize]])\n    net4 <- bereFull(eclipse$motif,eclipse$exp[,homosubset2[(sampleSize+1):(sampleSize*2)]])\n    hetsubset <- sample(c(homosubset1,homosubset2))\n    net5 <- bereFull(eclipse$motif,eclipse$exp[,hetsubset[1:sampleSize]])\n    net6 <- bereFull(eclipse$motif,eclipse$exp[,hetsubset[(sampleSize+1):(sampleSize*2)]])\n        \n    \n    tm <- transformation.matrix(net1, net3, remove.diagonal=T, method=\"ols\")\n    resMatrix[i*4+1,] <- apply(tm,2,function(x){t(x)%*%x})\n    tm <- transformation.matrix(net1, net4, remove.diagonal=T, method=\"ols\")\n    resMatrix[i*4+2,] <- apply(tm,2,function(x){t(x)%*%x})\n    tm <- transformation.matrix(net2, net3, remove.diagonal=T, method=\"ols\")\n    resMatrix[i*4+3,] <- apply(tm,2,function(x){t(x)%*%x})\n    tm <- transformation.matrix(net2, net4, remove.diagonal=T, method=\"ols\")\n    resMatrix[i*4+4,] <- apply(tm,2,function(x){t(x)%*%x})\n    \n    tm <- transformation.matrix(net1, net2, remove.diagonal=T, method=\"ols\")\n    nullMatrix[i*2+1,] <- apply(tm,2,function(x){t(x)%*%x})\n    tm <- transformation.matrix(net3, net4, remove.diagonal=T, method=\"ols\")\n    nullMatrix[i*2+2,] <- apply(tm,2,function(x){t(x)%*%x})\n    \n    tm <- transformation.matrix(net5, net6, remove.diagonal=T, method=\"ols\")\n    hetMatrix[i+1,] <- apply(tm,2,function(x){t(x)%*%x})\n    \n}\ncolnames(resMatrix) <- colnames(tm)\ncolnames(nullMatrix) <- colnames(tm)\n\ntranscriptionFactor <- \"E2F3\"\nvalues <- c(resMatrix[,transcriptionFactor], nullMatrix[,transcriptionFactor])\nxvalues <- c(rep(\"obs\",length(resMatrix[,transcriptionFactor])), rep(\"null\",length(nullMatrix[,transcriptionFactor])))\nqplot(y=values,x=xvalues, geom = \"boxplot\", main=paste(\"Observed vs Null for\",transcriptionFactor))\n\nhetValues <- sort(c(resMatrix)[c(F,T)])\nhomValues <- sort(c(nullMatrix))\nqplot(y=hetValues, x=homValues, main=paste(\"QQ plot, homogenous networks vs hetergenous networks (all null)\"))+ geom_abline(intercept = 0, slope = 1)\n\n\n\n# 7/22/15 Plots for demo\nsamp <- sample(1:100)\ngeneX<-c(rnorm(50,0),rnorm(50,5))[samp]\ngeneY<-c(rnorm(50,0),rnorm(50,5))[samp]\ncol<-c(rep(\"red\",50),rep(\"blue\",50))\nplot(geneX,geneY,main=\"Expr for two genes\",col=col)\nabline(lm(geneY[1:50]~geneX[1:50]), col=\"red\" )\nabline(lm(geneY[51:100]~geneX[51:100]), col=\"blue\" )\nlegend(-2,7,       c(\"Null COPD\",\"Null SMC\"),       lty=c(1,1,1),lwd=c(2.5,2.5,2.5),col=c(\"blue\",\"red\"))\n\n\n#8/10/15 Plot for comparison of two TM TF-TF transitions\nqplot(c(tm.observed.COPGene[highlight.tfs,highlight.tfs]),c(tm.observed.ECLIPSE[highlight.tfs,highlight.tfs]), size=20, color=c(sapply(highlight.tfs, rep, 9)))\n\n\n# 10/9/15 exploring properties of extreme p-values\nlibrary(MASS)\nlibrary(pcalg)\n\nnumPerms <- 10000\nnumSamples <- 10000\nprobGenos <- c(rep(.02,numSamples/2),rep(.01,numSamples/2))\nprobPhenos <- c(rep(.1,numSamples/2),rep(.02,numSamples/2))\n\nsuspectLoci <- rbinom(numSamples, size=1, prob=probGenos)\ncorrectionVec <- c(rep(0,numSamples/2),rep(1,numSamples/2))\nx <- cbind(1, correctionVec)\ncorrectionHat  <- x %*% ginv(t(x)%*%x) %*% t(x)\nsuspectFitted <- correctionHat %*% suspectLoci\ncorrectedSuspect <- suspectLoci - suspectFitted\nsuspectPheno <- replicate(numPerms, rbinom(numSamples, size=1, prob=probPhenos))\nsuspectPhenoFitted <- correctionHat %*% suspectPheno\ncorrectedsuspectPheno <- suspectPheno - suspectPhenoFitted\ncorrelations <- cor(correctedSuspect, correctedsuspectPheno)\nuncorrectedCorrelations <- cor(suspectLoci, suspectPheno)\n\nxProb <- suspectFitted/2\nxVariances <- 2*xProb*(1-xProb) #variance of Binomial(2,xProb)\n yVariances <- suspectPhenoFitted*(1-suspectPhenoFitted)\n# yVariances <- rbind(matrix(.02*.98,nrow=numSamples/2,ncol=numPerms),matrix(.09,nrow=numSamples/2,ncol=numPerms))\n#yVariances <- matrix(probPhenos*(1-probPhenos),nrow=numSamples,ncol=numPerms)\n\nzvar <- t(yVariances)%*%xVariances\nnumerator <- zvar\ndenominator <- colSums(yVariances)%*%t(colSums(xVariances))\nvarRsq <- numerator/denominator\nvarianceFactor <- 1/varRsq\nwhich(is.nan(c(varianceFactor)))\n\nnullnegLogPValue <- -log((1:numPerms)/numPerms)\nnegLogPValueUncorrected <- -log(1-pt(uncorrectedCorrelations*sqrt(c(numSamples-2)/c(1-uncorrectedCorrelations^2)), numSamples))\nnegLogPValue <- -log(1-pt(correlations*sqrt(c(varianceFactor-2)/c(1-correlations^2)), varianceFactor))\nnegLogPValueN <- -log(1-pt(correlations*sqrt(c(numSamples-2)/c(1-correlations^2)), numSamples))\nplot(sort(c(nullnegLogPValue)), sort(c(negLogPValueN),na.last=F), col=\"red\")\npoints(sort(c(nullnegLogPValue)), sort(c(negLogPValue),na.last=F), col=\"blue\")\npoints(sort(c(nullnegLogPValue)), sort(c(negLogPValueUncorrected),na.last=F), col=\"black\")\nlegend(4,2, c(\"Uncorrected\",\"Corrected by pop\",\"Corrected by pop and variance\"), lty=1,lwd=5,col=c(\"black\",\"red\",\"blue\"))\nabline(0,1)\n\n\ncombinedMat<- cbind(suspectLoci, correctionVec, suspectPheno)\ng.pvalue <- sapply(which(negLogPValueN>5 & negLogPValueN<5.3), function(i){\n    -log(gSquareBin(1,i+2,2,combinedMat))\n    })\ng.pvalue\n",
    "created" : 1437586356999.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "85410596",
    "id" : "A732B0B5",
    "lastKnownWriteTime" : 1445035323,
    "path" : "~/gd/Harvard/Research/R_workspace/playground.R",
    "project_path" : "playground.R",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}