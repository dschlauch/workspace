{
    "contents" : "#' Bi-partite network analysis tools\n#'\n#' This function analyzes a bi-partite network, such as a Transcription factor to gene network derived from the PANDA algorithm.\n#'\n#' @param net1 starting network, a genes by transcription factors data.frame with scores for the existence of edges between\n#' @param net2 final network, a genes by transcription factors data.frame with scores for the existence of edges between\n#' @param by.tfs logical indicating a transcription factor based transformation.  If false, gives gene by gene transformation matrix\n#' @param remove.diagonal logical for returning a result containing 0s across the diagonal\n#' @param method character specifying which algorithm to use, default='kabsch'\n#' @keywords keywords\n#' @export\n#' @examples\n#' data(yeast.panda)\n#' t.matrix <- transformation.matrix(yeast.panda$cell.cycle, yeast.panda$stress.response)\n#' hcl.heatmap.plot(t.matrix, method=\"pearson\")\ntransformation.matrix <- function(network.1, network.2, by.tfs=T, standardize=T, remove.diagonal=T, method=\"ols\"){\n  if(is.list(network.1)&&is.list(network.2)){\n    if(by.tfs){\n      net1 <- t(network.1$reg.net)\n      net2 <- t(network.2$reg.net)\n    } else {\n      net1 <- network.1$reg.net\n      net2 <- network.2$reg.net\n    }\n  } else if(is.matrix(network.1)&&is.matrix(network.2)){\n    if(by.tfs){\n      net1 <- t(network.1)\n      net2 <- t(network.2)\n    } else {\n      net1 <- network.1\n      net2 <- network.2\n    }\n  } else {\n    stop(\"Networks must be lists or matrices\")\n  }\n  #gene.trans.matrix <- svd(net2)$v %*% diag(1/svd(net2)$d) %*% t(svd(net2)$u) %*% net1\n  if (method == \"kabsch\"){\n    tf.trans.matrix <- kabsch(net1,net2)\n  }\n  if (method == \"old\"){\n    svd.net2 <- svd(net2)\n    tf.trans.matrix <- svd.net2$v %*% diag(1/svd.net2$d) %*% t(svd.net2$u) %*% net1\n  }\n  if (method == \"ols\"){\n    # rewrote 'same column priority' feature\n    colFactor <- colSums(net1)/colSums(net2)\n    net2.star <- net2-sweep(net1, 2, colFactor, '*')\n    tf.trans.matrix <- ginv(t(net1)%*%net1)%*%t(net1)%*%net2.star\n    print(\"Using OLS method\")\n    \n  }\n  if (standardize){\n    tf.trans.matrix <- apply(tf.trans.matrix, 1, function(x){\n      #   x.zero <- (x-mean(x))\n      x/sum(abs(x))\n    })\n  }\n\n  if (remove.diagonal){\n    diag(tf.trans.matrix) <- 0\n  }\n  # Add column labels\n  colnames(tf.trans.matrix) <- rownames(tf.trans.matrix)\n  tf.trans.matrix\n}\nplottm <- function(melt.tm,title=\"Transition Matrix\"){\n    ggplot(melt.tm, aes(y=Var1,x=Var2)) + \n        ggtitle(title) + \n        geom_tile(aes(fill=value)) + \n        scale_fill_gradient(low=\"blue\", high=\"yellow\") + \n        xlab(\"\") + \n        ylab(\"\") +\n        theme(axis.text.x = element_text(angle = 90,hjust=1,vjust=0.5))\n}\nkabsch <- function(P,Q){\n\n  P <- apply(P,2,function(x){\n    x - mean(x)\n  })\n  Q <- apply(Q,2,function(x){\n    x - mean(x)\n  })\n  covmat <- cov(P,Q)\n  P.bar <- colMeans(P)\n  Q.bar <- colMeans(Q)\n  num.TFs <- ncol(P)    #n\n  num.genes <- nrow(P)  #m\n\n#   covmat <- (t(P)%*%Q - P.bar%*%t(Q.bar)*(num.genes))\n\n  svd.res <- svd(covmat-num.TFs*Q.bar%*%t(P.bar))\n\n  # Note the scalar multiplier in the middle.\n  # NOT A MISTAKE!\n  c.k <- colSums(P %*% svd.res$v * Q %*% svd.res$u)-num.genes*(P.bar%*%svd.res$v)*(Q.bar%*%svd.res$u)\n\n  E <- diag(c(sign(c.k)))\n\n  W <- svd.res$v %*% E %*% t(svd.res$u)\n  rownames(W) <- colnames(P)\n  colnames(W) <- colnames(P)\n  W\n}\n\n#' Sum of squared off-diagonal mass\n#'\n#' This function calculates the off-diagonal sum of squared mass for a transition matrix\n#'\n#' @param tm a transition matrix for two bipartite networks\n#' @keywords keywords\n#' @export\n#' @examples\n#' data(yeast.panda)\n#' t.matrix <- transformation.matrix(yeast.panda$cell.cycle, yeast.panda$stress.response)\n#' ssodm(t.matrix)\nssodm <-  function(tm){\n  diag(tm)<-0\n  sort(apply(tm,1,function(x){t(x)%*%x}))\n}\n\n#' Transformation matrix plot\n#'\n#' This function plots a hierachically clustered heatmap and corresponding dendrogram of a transaction matrix\n#'\n#' @param net1 starting network, a genes by transcription factors data.frame with scores for confidence in the existence of edges between\n#' @param method distance metric for hierarchical clustering.  Default is \"Pearson correlation\"\n#' @keywords keywords\n#' @export\n#' @examples\n#' data(yeast.panda)\n#' t.matrix <- transformation.matrix(yeast.panda$cell.cycle, yeast.panda$stress.response)\n#' hcl.heatmap.plot(t.matrix, method=\"pearson\")\nhcl.heatmap.plot <- function(x, method=\"pearson\"){\n  if(method==\"pearson\"){\n    dist.func <- pearson.dist\n  } else {\n    dist.func <- dist\n  }\n  # x <- as.matrix(scale(mtcars))\n  x <- scale(x)\n  dd.col <- as.dendrogram(hclust(dist.func(x)))\n  col.ord <- order.dendrogram(dd.col)\n\n  dd.row <- as.dendrogram(hclust(dist.func(t(x))))\n  row.ord <- order.dendrogram(dd.row)\n\n  xx <- x[col.ord, row.ord]\n  xx_names <- attr(xx, \"dimnames\")\n  df <- as.data.frame(xx)\n  colnames(df) <- xx_names[[2]]\n  df$Var1 <- xx_names[[1]]\n  df$Var1 <- with(df, factor(Var1, levels=Var1, ordered=TRUE))\n  mdf <- melt(df)\n\n\n  ddata_x <- dendro_data(dd.row)\n  ddata_y <- dendro_data(dd.col)\n\n  ### Set up a blank theme\n  theme_none <- theme(\n    panel.grid.major = element_blank(),\n    panel.grid.minor = element_blank(),\n    panel.background = element_blank(),\n    axis.title.x = element_text(colour=NA),\n    axis.title.y = element_blank(),\n    axis.text.x = element_blank(),\n    axis.text.y = element_blank(),\n    axis.line = element_blank()\n    #axis.ticks.length = element_blank()\n  )\n  ### Set up a blank theme\n  theme_heatmap <- theme(\n    panel.grid.major = element_blank(),\n    panel.grid.minor = element_blank(),\n    panel.background = element_blank(),\n    axis.title.x = element_text(colour=NA),\n    axis.title.y = element_blank(),\n    axis.text.x = element_blank(),\n    axis.text.y = element_blank(),\n    axis.line = element_blank()\n    #axis.ticks.length = element_blank()\n  )\n  ### Create plot components ###\n  # Heatmap\n  p1 <- ggplot(mdf, aes(x=variable, y=Var1)) +\n    geom_tile(aes(fill=value)) + scale_fill_gradient2() + theme(axis.text.x = element_text(angle = 90, hjust = 1))\n\n  # Dendrogram 1\n  p2 <- ggplot(segment(ddata_x)) +\n    geom_segment(aes(x=x, y=y, xend=xend, yend=yend)) +\n    theme_none + theme(axis.title.x=element_blank())\n\n  # Dendrogram 2\n  p3 <- ggplot(segment(ddata_y)) +\n    geom_segment(aes(x=x, y=y, xend=xend, yend=yend)) +\n    coord_flip() + theme_none\n\n  ### Draw graphic ###\n\n  grid.newpage()\n  print(p1, vp=viewport(0.80, 0.8, x=0.400, y=0.40))\n  print(p2, vp=viewport(0.73, 0.2, x=0.395, y=0.90))\n  print(p3, vp=viewport(0.20, 0.8, x=0.910, y=0.43))\n}\n\n#' Principal Components plot of transformation matrix\n#'\n#' This function plots the first two principal components for a transaction matrix\n#'\n#' @param tm a transition matrix for a bipartite network\n#' @param title The title of the plot\n#' @param clusters A vector indicating the colors to be plotted for each node\n#' @param alpha A vector indicating the level of transparency to be plotted for each node\n#' @keywords keywords\n#' @export\n#' @examples\n#' data(yeast.panda)\n#' t.matrix <- transformation.matrix(yeast.panda$cell.cycle, yeast.panda$stress.response)\n#' p.values <- runif(ncol(t.matrix))  # Generate a uniform random to simulate p.values\n#' clusters <- kmeans(t.matrix,3)$cluster # Color the nodes according to cluster membership\n#' pca.plot(t.matrix,title=\"PCA Plot of Transition - Cell Cycle vs Stress Response\", clusters=clusters,alpha=p.values)\npca.plot <-  function(tm, title=\"PCA Plot of Transition\", clusters=1, alpha=1){\n  tm.pca <- princomp(tm)\n  odsm <- ssodm(tm)\n  odsm.scaled <- 2*(odsm-mean(odsm))/sd(odsm)+4\n  scores.pca <- as.data.frame(tm.pca$scores)\n  scores.pca <- cbind(scores.pca,'node.names'=rownames(scores.pca))\n  ggplot(data = scores.pca, aes(x = Comp.1, y = Comp.2, label = node.names)) +\n    geom_hline(yintercept = 0, colour = \"gray65\") +\n    geom_vline(xintercept = 0, colour = \"gray65\") +\n    geom_text(size = odsm.scaled, alpha=alpha, color=clusters) +\n    ggtitle(title)\n}\n\n#' This function plots the Off diagonal mass of an observed Transition Matrix compared to a set of null TMs\n#'\n#' @param tm.obs The observed transition matrix\n#' @param tm.null A list of null transition matrices\n#' @keywords keywords\n#' @export\n#' @examples\n#' example1\nssodm.plot <- function(tm.obs, tm.null, sort.by.sig=F, rescale=F, plot.title=NA, highlight.tfs=NA){\n  if(is.na(plot.title)){\n    plot.title <- \"SSODM observed and null\"\n  }\n  num.iterations <- length(tm.null)\n  # Calculate the off-diagonal squared mass for each transition matrix\n  null.SSODM <- lapply(tm.null,function(x){\n    apply(x,1,function(y){t(y)%*%y})\n  })\n  null.ssodm.matrix <- matrix(unlist(null.SSODM),ncol=num.iterations)\n  null.ssodm.matrix <- t(apply(null.ssodm.matrix,1,sort))\n\n  ssodm <- apply(tm.obs,1,function(x){t(x)%*%x})\n\n  # Get p-value (rank of observed within null ssodm)\n  #   p.values <- sapply(1:length(ssodm),function(i){\n  #     1-findInterval(ssodm[i], null.ssodm.matrix[i,])/num.iterations\n  #   })\n  p.values <- 1-pnorm(sapply(1:length(ssodm),function(i){\n    (ssodm[i]-mean(null.ssodm.matrix[i,]))/sd(null.ssodm.matrix[i,])\n  }))\n  t.values <- sapply(1:length(ssodm),function(i){\n      (ssodm[i]-mean(null.ssodm.matrix[i,]))/sd(null.ssodm.matrix[i,])\n  })\n\n  # Process the data for ggplot2\n  combined.mat <- cbind(null.ssodm.matrix, ssodm)\n  colnames(combined.mat) <- c(rep('Null',num.iterations),\"Observed\")\n\n\n  if (rescale){\n    combined.mat <- t(apply(combined.mat,1,function(x){\n      (x-mean(x[-(num.iterations+1)]))/sd(x[-(num.iterations+1)])\n    }))\n    x.axis.order <- rownames(tm.null[[1]])[order(-t.values)]\n    x.axis.size  <- 10 # pmin(15,7-log(p.values[order(p.values)]))\n  } else {\n    x.axis.order <- rownames(tm.null[[1]])\n    x.axis.size  <- pmin(15,7-log(p.values))\n  }\n\n  null.SSODM.melt <- melt(combined.mat)[,-1][,c(2,1)]\n  null.SSODM.melt$TF<-rep(rownames(tm.null[[1]]),num.iterations+1)\n\n  ## Plot the data\n  ggplot(null.SSODM.melt, aes(x=TF, y=value))+\n    geom_point(aes(size=1,color=factor(Var2),alpha = .5*as.numeric(factor(Var2)))) +\n    scale_color_manual(values = c(\"blue\", \"red\")) +\n    scale_x_discrete(limits = x.axis.order ) +\n    theme(legend.title=element_blank(),axis.text.x = element_text(colour = 1+x.axis.order%in%highlight.tfs, angle = 90, hjust = 1, size=x.axis.size,face=\"bold\")) +\n    ylab(\"Sum of Squared Off-Diagonal Mass\") +\n    ggtitle(plot.title)\n  \n}\n\n#' Calculate p-values for a tranformation matrix\n#'\n#' This function calculates the significance of an observed transition matrix given a set of null transition matrices\n#'\n#' @param tm.obs The observed transition matrix\n#' @param tm.null A list of null transition matrices\n#' @param method one of 'z-score' or 'non-parametric'\n#' @keywords keywords\n#' @export\n#' @examples\n#' example1\ncalculate.tm.p.values <- function(tm.obs, tm.null, method=\"z-score\"){\n  num.iterations <- length(tm.null)\n  # Calculate the off-diagonal squared mass for each transition matrix\n  null.SSODM <- lapply(tm.null,function(x){\n    apply(x,1,function(y){t(y)%*%y})\n  })\n  null.ssodm.matrix <- matrix(unlist(null.SSODM),ncol=num.iterations)\n  null.ssodm.matrix <- t(apply(null.ssodm.matrix,1,sort))\n\n  ssodm <- apply(tm.obs,1,function(x){t(x)%*%x})\n\n  # Get p-value (rank of observed within null ssodm)\n  if(method==\"non-parametric\"){\n    p.values <- sapply(1:length(ssodm),function(i){\n      1-findInterval(ssodm[i], null.ssodm.matrix[i,])/num.iterations\n    })\n  } else if (method==\"z-score\"){\n    p.values <- pnorm(sapply(1:length(ssodm),function(i){\n      (ssodm[i]-mean(null.ssodm.matrix[i,]))/sd(null.ssodm.matrix[i,])\n    }))\n  } else {\n    print('Undefined method')\n  }\n  p.values\n}\n\n#' This function generates n null transformation matrices from a folder of networks\n#'\n#' @param path a path to the folder containing the network files (and only the network files)\n#' @param keyword a string to be used as a key for distinguishing group 1 from group 2\n#' @keywords keywords\n#' @export\n#' @examples\n#' example1\nload.null.tms <- function(dir.path, keyword=\"sub1\"){\n  perm.filenames <- list.files(dir.path)\n  null.networks.list <- split(lapply(file.path(dir.path,perm.filenames), function(x){\n    file.to.regnet(x)\n  }),grepl(keyword, perm.filenames))\n\n  # Calculate the transition matrices between those \"null\" networks\n  tm.null <- lapply(1:length(null.networks.list[[1]]), function(x){\n    transformation.matrix(null.networks.list[[1]][[x]], null.networks.list[[2]][[x]])\n  })\n  tm.null\n}\n#' This function reads in panda C output and converts to a reg.net mxn matrix\n#'\n#' @param path a path to the folder containing the network files (and only the network files)\n#' @param keyword a string to be used as a key for distinguishing group 1 from group 2\n#' @keywords keywords\n#' @export\n#' @examples\n#' example1\nfile.to.regnet <- function(file.name){\n  library(reshape2)\n  library(ggplot2)\n  reg.net.melt <- read.table(file.name, header=F)\n  reg.net <- dcast(reg.net.melt, V1 ~ V2, value.var='V4')\n  rownames(reg.net) <- reg.net[,1]\n  reg.net <- as.matrix(reg.net[,-1])\n}\n",
    "created" : 1438018633715.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2930002382",
    "id" : "3A9B8EE6",
    "lastKnownWriteTime" : 1439325797,
    "path" : "~/gd/Harvard/Research/R_Packages/bptools/R/analysis_functions.R",
    "project_path" : null,
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}