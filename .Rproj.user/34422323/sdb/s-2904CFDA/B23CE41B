{
    "contents" : "library(reshape2)\nlibrary(bereR)\nlibrary(pandaR)\nlibrary(ROCR)\nlibrary(dplyr)\nlibrary(penalized)\n\nvalidateMethodsOnDataset <- function(dataset){\n    source(paste(\"~/gd/Harvard/Research/R_workspace/\",dataset,\".R\",sep=\"\"))\n    \n    # Data Procession\n    # Remove non-target genes\n    exprData <- exprData[rownames(exprData)%in%unique(goldStandard[,2]),]\n    # order Genes\n    exprData <- scale(exprData[order(rownames(exprData)),])\n    if (ncol(exprData)>200){\n        # Keep number of samples under 200\n        exprData <- exprData[,1:100]\n    }\n    # Get subset of expression data that is relevant (possibly keep all)\n#     dataset <- \"DREAM5c_G313\"\n#     exprData <- exprData[,!grep(\"G313\",chipFeatures$V5)]\n    \n    # Run algorithms -  PANDA, BERE (with Corr method, LDA, and weighted correlation diff), straight up corellation\n    \n    ########## PANDA\n    pandaMelt <- panda(motifs, exprData, progress=F)@regNet %>% melt %>% meltToCharacter %>% removeDiagonal %>% sortMelt\n\n    ########## Degree only approach\n    degreeMelt <- degreeApproach(motifs) %>% melt %>% meltToCharacter %>% removeDiagonal %>% sortMelt\n    \n    ##########  BERE\n    bereMelt <- bere(motifs, exprData, cpp=F, verbose=F) %>% melt %>% meltToCharacter %>% removeDiagonal %>% sortMelt\n    \n    ##########  LDA BERE\n    ldabereMelt <- ldaBERE(motifs, exprData) %>% melt %>% meltToCharacter %>% removeDiagonal %>% sortMelt\n\n    ##########  FULL BERE\n    fullbereMelt1 <- bereFull(motifs, exprData, alpha=1, lambda=1) %>% melt %>% meltToCharacter %>% removeDiagonal %>% sortMelt\n    fullbereMelt2 <- bereFull(motifs, exprData, alpha=1, lambda=2) %>% melt %>% meltToCharacter %>% removeDiagonal %>% sortMelt\n    fullbereMelt5 <- bereFull(motifs, exprData, alpha=1, lambda=5) %>% melt %>% meltToCharacter %>% removeDiagonal %>% sortMelt\n    fullbereMelt10 <- bereFull(motifs, exprData, alpha=1, lambda=10) %>% melt %>% meltToCharacter %>% removeDiagonal %>% sortMelt\n    fullbereMelt15 <- bereFull(motifs, exprData, alpha=1, lambda=15) %>% melt %>% meltToCharacter %>% removeDiagonal %>% sortMelt\n    fullbereMelt25 <- bereFull(motifs, exprData, alpha=1, lambda=25) %>% melt %>% meltToCharacter %>% removeDiagonal %>% sortMelt\n    fullbereMelt40 <- bereFull(motifs, exprData, alpha=1, lambda=40) %>% melt %>% meltToCharacter %>% removeDiagonal %>% sortMelt\n    fullbereMelt1000 <- bereFull(motifs, exprData, alpha=1, lambda=1000) %>% melt %>% meltToCharacter %>% removeDiagonal %>% sortMelt\n\n    \n    ##########  Straight TF correlation\n    tfCorMelt <- abs(cor(x=t(exprData[rownames(exprData) %in% transFactors,]), y=t(exprData))) %>% melt %>% meltToCharacter %>% removeDiagonal %>% sortMelt\n    \n    ##########  Weighted Cor diff\n#    weightedCorDiffMelt <- t(weightedCorDiff) %>% melt %>% meltToCharacter %>% removeDiagonal %>% sortMelt\n    \n    ###################################################  \n    ##########  Validate Results with gold standard\n    ###################################################\n    goldStandard <- goldStandard %>% meltToCharacter %>% removeDiagonal %>% sortMelt\n    motifs <- motifs %>% meltToCharacter %>% removeDiagonal %>% sortMelt\n\n    ###################################################  \n    ##########  Plot Results against gold standard\n    ###################################################\n    datalist <- list(\"Gold Standard\"=goldStandard[,3],\n                     \"Degree-only\"=degreeMelt[,3],\n                     \"PANDA\"=pandaMelt[,3],\n                    \"BERE\"=bereMelt[,3],\n                    \"LDA BERE\"=ldabereMelt[,3],\n                    \"Full BERE 1\"=fullbereMelt1[,3],\n                    \"Full BERE 2\"=fullbereMelt2[,3],\n                    \"Full BERE 5\"=fullbereMelt5[,3],\n                    \"Full BERE 10\"=fullbereMelt10[,3],\n                    \"Full BERE 15\"=fullbereMelt15[,3],\n                    \"Full BERE 25\"=fullbereMelt25[,3],\n                    \"Full BERE 40\"=fullbereMelt40[,3],\n                    \"Full BERE 1000\"=fullbereMelt1000[,3],\n                    \"TF Corr\"=tfCorMelt[,3],#+motifs[,3],\n                    \"Motifs\"=motifs[,3])\n    TFsubset <- goldStandard[,1] %in% unique(goldStandard[,1])[6]\n    \n    png(filename=paste(\"./output/\",dataset,\"_all.png\",sep=\"\"))\n    plotROC(datalist, \"all\", organism=dataset, goldStandard)\n    dev.off()\n    png(filename=paste(\"./output/\",dataset,\"_motif.png\",sep=\"\"))\n    plotROC(datalist, \"motif\", organism=dataset, goldStandard)\n    dev.off()\n    png(filename=paste(\"./output/\",dataset,\"_nonmotif.png\",sep=\"\"))\n    plotROC(datalist, \"nonmotif\", organism=dataset, goldStandard)\n    dev.off()\n}\n\n\n\n###################################################  \n##########  Functions\n###################################################\n# New ROC method\nplotROC <- function(datalist, includeSubset=\"all\", organism=\"\", goldStandard=NA, TFsubset=NA){\n    require(ROCR)\n    \n    methods <- names(datalist)[-1] # Remove gold standard from methods list\n    if(includeSubset==\"all\"){ subset <- rep(T,length(datalist[[\"Gold Standard\"]]))}\n    if(includeSubset==\"motif\"){ subset <- (datalist[[\"Motifs\"]]==1)}\n    if(includeSubset==\"nonmotif\"){ subset <- (datalist[[\"Motifs\"]]==0)}\n    \n    if(!all(is.na(TFsubset))){\n        subset <- subset*TFsubset==1\n    }\n    plotList <- lapply(methods, function(x){\n        methodPred  <- prediction(datalist[[x]][subset], datalist[[\"Gold Standard\"]][subset])\n        roc.methodPred  <- performance(methodPred, measure = c(\"tpr\",\"auc\"), x.measure = \"fpr\")\n        auc.methodPred  <- performance(methodPred, \"auc\")@y.values[[1]]\n        list(\"roc.methodPred\"=roc.methodPred, \"auc.methodPred\"=auc.methodPred)\n    })\n    names(plotList) <- methods\n    plot(plotList[[\"PANDA\"]][[\"roc.methodPred\"]], main=paste(organism, includeSubset,\"ROC\"), col = 1, lwd=3)\n    mapply(function(x,index){\n        lines(plotList[[x]][[\"roc.methodPred\"]]@x.values[[1]], plotList[[x]][[\"roc.methodPred\"]]@y.values[[1]], col = (index), lwd=3)\n    }, methods, 1:length(methods))\n    legendLabels <- c(sapply(methods, function(x){\n        paste(x, round(plotList[[x]][[\"auc.methodPred\"]],4))\n    }))\n    \n\n    legend(.5,.6, legendLabels, lty=rep(1,length(methods)),lwd=rep(5,length(methods)),col=1:length(methods))\n    rocPerTFResults <- c()\n    if(!all(is.na(goldStandard))){\n        # Calculate average ROC per TF\n        tfs <- unique(goldStandard[,1])\n        goldcounts <- table(goldStandard[subset,c(1,3)])[,2]\n        tfs <- tfs[goldcounts>0]\n        goldcounts <- goldcounts[goldcounts>0]\n        \n        TFaucrocs <- sapply(tfs, function(tf){\n            tfsub <- goldStandard[,1] %in% tf\n            sapply(methods, function(x){\n                methodPred  <- prediction(datalist[[x]][subset & tfsub], datalist[[\"Gold Standard\"]][subset & tfsub])\n                performance(methodPred, \"auc\")@y.values[[1]]\n            })\n        })\n        meanROC <- apply(TFaucrocs,1,mean)\n        wmeanROC <- apply(TFaucrocs,1,function(x){\n            sum(x*goldcounts)/sum(goldcounts)\n        })\n        rocPerTFResults <- c(rocPerTFResults, paste(\"Average within TF ROC, weighted by gold standard hits -\", organism, includeSubset))\n        rocPerTFResults <- c(rocPerTFResults, wmeanROC)\n    }\n    write.table(rocPerTFResults, file=paste(\"./output/\",organism, includeSubset,\"_aucroc_per_TF.txt\",sep=\"\"))\n}\nsortMelt <- function(df){df[order(df[,1],df[,2]),]}\nremoveDiagonal <- function(x){x[x[,1]!=x[,2],]}\nmeltToCharacter <- function(x){\n    x[,1]<-as.character(x[,1])\n    x[,2]<-as.character(x[,2])\n    x\n}",
    "created" : 1437586365433.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3906998795",
    "id" : "B23CE41B",
    "lastKnownWriteTime" : 1433534447,
    "path" : "~/gd/Harvard/Research/R_workspace/validation.R",
    "project_path" : "validation.R",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}