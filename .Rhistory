roc.methodPred  <- performance(methodPred, measure = c("tpr","auc"), x.measure = "fpr")
auc.methodPred  <- performance(methodPred, "auc")@y.values[[1]]
plot(roc.methodPred, main=title, col = 1, lwd=3)
p.value <- t.test(c(netA), c(matrixB_GS)>.5)$p.value
if(p.value<2e-16){
p.value <- "p < 2e-16"
} else {
p.value <- paste0("p = ", p.value)
}
abline(0,1)
legend("bottomright", paste0("AUC = ",round(auc.methodPred,4)," \n(",p.value,")"), lty=1,lwd=5,col=1, cex=2)
}
# getAUCROC <- function(netA){
#     methodPred  <- prediction(c(netA), c(matrixA_GS)>.5)
#     roc.methodPred  <- performance(methodPred, measure = c("tpr","auc"), x.measure = "fpr")
#     c(performance(methodPred, "auc")@y.values[[1]])
# }
png("simulated_network_roc.png", width=1800, height=1000)
par(mfrow=c(2,4),oma=c(0,0,4,0),cex.main = 4)
networkAUCROC(pearsonAdjMatA, "Correlation")
networkAUCROC(wgcnaA6, "WGCNA")
networkAUCROC(aracneA, "ARACNE")
networkAUCROC(clrA, "CLR")
networkAUCROC(tomA, "TOM")
networkAUCROC(motifs[,1:numGenes], "Motifs")
networkAUCROC(pandaResA, "PANDA")
networkAUCROC(bereResA, "BERE")
title("ROC plots for simulated networks", outer=TRUE)
dev.off()
dim(tm.panda)
dim(directTMpanda)
directTMpanda[1:5,1:5]
directbereRes[1:5,1:5]
tm.bere[1:5,1:5]
ROCforTransitions(tm.bere, directbereRes, method="BERE")
dev.off()
ROCforTransitions(tm.bere, directbereRes, method="BERE")
heatmap.2(tm.bere, col=colorRampPalette(c("blue", "white", "red"))(n = 1000), density.info="none", trace="none", dendrogram="none", Colv=FALSE, Rowv=FALSE)
heatmap.2(tm.gs, col=colorRampPalette(c("blue", "white", "red"))(n = 1000), density.info="none", trace="none", dendrogram="none", Colv=FALSE, Rowv=FALSE)
bereResA[1:5,1:5]
matrixA_GS[1:5,1:5]
sum(diag(matrixA_GS))
sum(diag(matrixA_GS)>0)
sum(matrixA_GS>0)
sum(matrixA_GS>0.001)
dim(matrixA_GS)
matrixA_GS[1:5,1:5]
sum(diag(tm.gs))
sum(abs(diag(tm.gs)))
set.seed(12345)
rnorm(10)
rnorm(10)
set.seed(12345)
rnorm(10)
rnorm(10)
set.seed(12345)
# For creating gene expression data
library(WGCNA)
library(bptools)
library(gplots)
library(ROCR)
library(penalized)
library(tidyr)
library(bereR)
library(pandaR)
library(corpcor)
library(nettools)
set.seed(12345)
numTFs <- 100
numGenes <- 5000
numTransitions <- 100
numSamples <- 500
geneNames <- paste0("Gene",1:numGenes)
TFNames <- paste0("TF",1:numTFs)
true_edges <- runif(numGenes*numTFs)*rbinom(numGenes*numTFs,1,prob=.2)
matrixA_GS <- matrix(true_edges,nrow=numTFs)
matrixB_GS <- matrixA_GS# + matrix(rnorm(10000)/10,nrow=10)
probs <- rexp(numTFs)
TFAs <- sample(1:numTFs,numTransitions, replace=T)
TFBs <- sample(1:numTFs,numTransitions, replace=T, probs)
TFBs[TFAs==TFBs] <- sample(1:numTFs,sum(TFAs==TFBs), replace=T)
sum(sum(TFAs==TFBs))
strengths <- (c(-50:-1,1:50))/50
for(i in 1:numTransitions){
matrixB_GS[TFBs[i],] <- matrixB_GS[TFBs[i],] + matrixA_GS[TFAs[i],]*strengths[i]
}
varcovA <- t(matrixA_GS)%*%matrixA_GS
varcovB <- t(matrixB_GS)%*%matrixB_GS
# Increase the noise
diag(varcovA) <- 4*diag(varcovA)
diag(varcovB) <- 4*diag(varcovB)
gexpA <- t(mvrnorm(n=numSamples, mu=rep(0,numGenes), Sigma=varcovA))
gexpB <- t(mvrnorm(n=numSamples, mu=rep(0,numGenes), Sigma=varcovB))
rownames(gexpA) <- geneNames
rownames(gexpB) <- geneNames
tfExpA <- matrixA_GS %*% gexpA
tfExpB <- matrixB_GS %*% gexpB
# Add a bunch of noise to the TF expressions
tfExpA <- t(scale(t(tfExpA))) + 2*matrix(rnorm(length(c(tfExpA))),nrow=nrow(tfExpA))
tfExpB <- t(scale(t(tfExpB))) + 2*matrix(rnorm(length(c(tfExpB))),nrow=nrow(tfExpB))
rownames(tfExpA) <- TFNames
rownames(tfExpB) <- TFNames
pearsonAdjMatA <- abs(cor(t(tfExpA), t(gexpA)))
pearsonAdjMatB <- abs(cor(t(tfExpB), t(gexpB)))
wgcnaA6 <- mat2adj(cbind(t(tfExpA), t(gexpA)), method="WGCNA")[1:numTFs,-(1:numTFs)]
wgcnaB6 <- mat2adj(cbind(t(tfExpB), t(gexpB)), method="WGCNA")[1:numTFs,-(1:numTFs)]
wgcnaA12 <- mat2adj(cbind(t(tfExpA), t(gexpA)), method="WGCNA", P=12)[1:numTFs,-(1:numTFs)]
wgcnaB12 <- mat2adj(cbind(t(tfExpB), t(gexpB)), method="WGCNA", P=12)[1:numTFs,-(1:numTFs)]
tomA <- mat2adj(cbind(t(tfExpA), t(gexpA)), method="TOM")[1:numTFs,-(1:numTFs)]
tomB <- mat2adj(cbind(t(tfExpB), t(gexpB)), method="TOM")[1:numTFs,-(1:numTFs)]
aracneA <- mat2adj(cbind(t(tfExpA), t(gexpA)), method="ARACNE")[1:numTFs,-(1:numTFs)]
aracneB <- mat2adj(cbind(t(tfExpB), t(gexpB)), method="ARACNE")[1:numTFs,-(1:numTFs)]
clrA <- mat2adj(cbind(t(tfExpA), t(gexpA)), method="CLR")[1:numTFs,-(1:numTFs)]
clrB <- mat2adj(cbind(t(tfExpB), t(gexpB)), method="CLR")[1:numTFs,-(1:numTFs)]
# mineA <- mat2adj(cbind(t(tfExpA), t(gexpA)), method="MINE", measure="MIC")[1:numTFs,-(1:numTFs)]
# mineB <- mat2adj(cbind(t(tfExpB), t(gexpB)), method="MINE", measure="MIC")[1:numTFs,-(1:numTFs)]
# 9/28/15
# Adding simulated motif data
motifs <- matrix(rbinom(length(true_edges), 1, .1+true_edges/5), nrow=numTFs)
rownames(motifs) <- TFNames
colnames(motifs) <- geneNames
TFsZeros <- diag(numTFs)
rownames(TFsZeros) <- TFNames
colnames(TFsZeros) <- TFNames
motifs <- cbind(motifs,TFsZeros)
motifsMelt <- melt(motifs)
colnames(motifsMelt) <- c("V1","V2","value")
gexpAWithTFs <- rbind(gexpA,tfExpA)
gexpBWithTFs <- rbind(gexpB,tfExpB)
bereAllA <- bere(motifsMelt, gexpAWithTFs, score="notincluded")#[TFNames,geneNames]
bereAllB <- bere(motifsMelt, gexpBWithTFs, score="notincluded")#[TFNames,geneNames]
bereAllA <- bereAllA[TFNames,]
bereAllB <- bereAllB[TFNames,]
bereResA <- bereAllA[,geneNames]
bereResB <- bereAllB[,geneNames]
pandaAllA <- panda(motifsMelt, gexpAWithTFs, hamming = 1e-02)@regNet
pandaAllB <- panda(motifsMelt, gexpBWithTFs, hamming = 1e-02)@regNet
pandaResA <- pandaAllA[,geneNames]
pandaResB <- pandaAllB[,geneNames]
## Compare to default strategy of pairwise results
corTFA <- mat2adj(t(tfExpA))
corTFB <- mat2adj(t(tfExpB))
directTMcor <- corTFA-corTFB
wgcnaTFA <- mat2adj(t(tfExpA), method="WGCNA")
wgcnaTFB <- mat2adj(t(tfExpB), method="WGCNA")
directTMwgcna <- wgcnaTFA-wgcnaTFB
tomTFA <- mat2adj(t(tfExpA), method="TOM")
tomTFB <- mat2adj(t(tfExpB), method="TOM")
directTMTOM <- tomTFA-tomTFB
wgcna12TFA <- mat2adj(t(tfExpA), method="WGCNA",P=12)
wgcna12TFB <- mat2adj(t(tfExpB), method="WGCNA",P=12)
directTMwgcna12 <- wgcna12TFA-wgcna12TFB
aracneTFA <- mat2adj(t(tfExpA), method="ARACNE")
aracneTFB <- mat2adj(t(tfExpB), method="ARACNE")
directTMaracne <- aracneTFA-aracneTFB
clrTFA <- mat2adj(t(tfExpA), method="CLR")
clrTFB <- mat2adj(t(tfExpB), method="CLR")
directTMclr <- clrTFA-clrTFB
directTMpanda <- pandaAllA[,-1:-numGenes]-pandaAllB[,-1:-numGenes]
directTMpanda <- directTMpanda[,rownames(directTMpanda)]
# Issue is here: Bere does not have TFs in results
directbereRes <- bereAllA[,TFNames]-bereAllB[,TFNames]
directbereRes <- directbereRes[TFNames,TFNames]
networkAUCROC <- function(netA, title=""){
methodPred  <- prediction(c(netA), c(matrixA_GS)>.5)
roc.methodPred  <- performance(methodPred, measure = c("tpr","auc"), x.measure = "fpr")
auc.methodPred  <- performance(methodPred, "auc")@y.values[[1]]
plot(roc.methodPred, main=title, col = 1, lwd=3)
p.value <- t.test(c(netA), c(matrixB_GS)>.5)$p.value
if(p.value<2e-16){
p.value <- "p < 2e-16"
} else {
p.value <- paste0("p = ", p.value)
}
abline(0,1)
legend("bottomright", paste0("AUC = ",round(auc.methodPred,4)," \n(",p.value,")"), lty=1,lwd=5,col=1, cex=2)
}
# getAUCROC <- function(netA){
#     methodPred  <- prediction(c(netA), c(matrixA_GS)>.5)
#     roc.methodPred  <- performance(methodPred, measure = c("tpr","auc"), x.measure = "fpr")
#     c(performance(methodPred, "auc")@y.values[[1]])
# }
png("simulated_network_roc.png", width=1800, height=1000)
par(mfrow=c(2,4),oma=c(0,0,4,0),cex.main = 4)
networkAUCROC(pearsonAdjMatA, "Correlation")
networkAUCROC(wgcnaA6, "WGCNA")
networkAUCROC(aracneA, "ARACNE")
networkAUCROC(clrA, "CLR")
networkAUCROC(tomA, "TOM")
networkAUCROC(motifs[,1:numGenes], "Motifs")
networkAUCROC(pandaResA, "PANDA")
networkAUCROC(bereResA, "BERE")
title("ROC plots for simulated networks", outer=TRUE)
dev.off()
# networkAUCROC(pandaResANULL, "PANDA NULL")
# networkAUCROC(bereResA, bereResB, "BERE")
# networkAUCROC(pearsonAdjMatA+motifs, pearsonAdjMatB+motifs, "WGCNA w/motif")
tm.gs        <- transformation.matrix(matrixA_GS, matrixB_GS, remove.diagonal=T, standardize=F, method="ols")
tm.pearson   <- transformation.matrix(pearsonAdjMatA, pearsonAdjMatB, remove.diagonal=T, standardize=F, method="ols")
tm.wgcna6    <- transformation.matrix(wgcnaA6, wgcnaB6, remove.diagonal=T, standardize=F, method="ols")
tm.wgcna12   <- transformation.matrix(wgcnaA12, wgcnaB12, remove.diagonal=T, standardize=F, method="ols")
tm.aracne    <- transformation.matrix(aracneA, aracneB, remove.diagonal=T, standardize=F, method="ols")
tm.clr       <- transformation.matrix(clrA, clrB, remove.diagonal=T, standardize=F, method="ols")
tm.tom       <- transformation.matrix(tomA, tomB, remove.diagonal=T, standardize=F, method="ols")
tm.panda     <- transformation.matrix(pandaResA, pandaResB, remove.diagonal=T, standardize=F, method="ols")
tm.bere      <- transformation.matrix(bereResA, bereResB, remove.diagonal=T, standardize=F, method="ols")
heatmap.2(tm.gs, col=colorRampPalette(c("blue", "white", "red"))(n = 1000), density.info="none", trace="none", dendrogram="none", Colv=FALSE, Rowv=FALSE)
heatmap.2(tm.pearson, col=colorRampPalette(c("blue", "white", "red"))(n = 1000), density.info="none", trace="none", dendrogram="none", Colv=FALSE, Rowv=FALSE)
heatmap.2(tm.wgcna6, col=colorRampPalette(c("blue", "white", "red"))(n = 1000), density.info="none", trace="none", dendrogram="none", Colv=FALSE, Rowv=FALSE)
heatmap.2(tm.panda, col=colorRampPalette(c("blue", "white", "red"))(n = 1000), density.info="none", trace="none", dendrogram="none", Colv=FALSE, Rowv=FALSE)
heatmap.2(tm.bere, col=colorRampPalette(c("blue", "white", "red"))(n = 1000), density.info="none", trace="none", dendrogram="none", Colv=FALSE, Rowv=FALSE)
################## Penalized matrix
# penalizedTM <- function(net1, net2){
#     net2.star <- sapply(1:numTFs, function(i,x,y){
#         lm(y[,i]~x[,i])$resid
#     }, net1, net2)
#     tm.penL1 <- sapply(1:numTFs, function(i){
#         #     z <- optL1(net2.star[,i], net1, fold=5, minlambda1=.1, maxlambda1=2, model="linear", standardize=T)
#         #     coefficients(z$fullfit, "penalized")
#         z <- penalized(net2.star[,i], net1, lambda1=1, model="linear", standardize=T)
#         coefficients(z, "penalized")
#     })
#     diag(tm.penL1)<-0
#     tm.penL1
# }
# tm.penL1 <- penalizedTM(t(pearsonAdjMatA),t(pearsonAdjMatB))
#
# heatmap.2(tm.penL1, col=colorRampPalette(c("blue", "white", "red"))(n = 1000), density.info="none", trace="none", dendrogram="none", Colv=FALSE, Rowv=FALSE)
#######################################
plotStrengthVsTransitionRank <- function(tm){
sortedODM <- sort(abs(c(tm)),decreasing=T)
transition.results <- cbind(TFAs,TFBs, strengths, diag(tm[TFAs,TFBs]))[order(-strengths),]
cbind(transition.results[,4],sapply(transition.results[,4], function(x){sum(sortedODM>abs(x))})+1)
#transition.ranks <- do.call(rbind, sapply(transition.results[,4], function(x){which(abs(x) == sort(abs(c(tm.noisy)),decreasing=T))}))[,1]
transition.ranks <- sapply(transition.results[,4], function(x){sum(sortedODM>abs(x))})+1
qplot(strengths, transition.ranks, main="Ranks of off-diagonal mass vs transition strength")+ ylim(0, numTFs^2)
}
plotStrengthVsTransitionRank(tm.pearson)
plotStrengthVsTransitionRank(tm.wgcna6)
plotStrengthVsTransitionRank(tm.wgcna12)
plotStrengthVsTransitionRank(tm.aracne)
plotStrengthVsTransitionRank(tm.clr)
plotStrengthVsTransitionRank(tm.tom)
plotStrengthVsTransitionRank(tm.panda)
plotStrengthVsTransitionRank(tm.bere)
dtfi_true <- apply(tm.gs, 1, function(x){sum(abs(x))})
dtfi_obs <- apply(tm.bere, 1, function(x){sum(abs(x))})
qplot(dtfi_true, dtfi_obs, main="Differential TF Involvement: Observed vs True")+ stat_smooth()
summary(lm(dtfi_true ~ dtfi_obs))
# ROC for transitions
ROCforTransitions <- function(tm, tm2, alpha=.001,method=""){
goldStandard <- abs(c(tm.gs))>alpha
methodPred  <- prediction(abs(c(tm)), goldStandard)
roc.methodPred  <- performance(methodPred, measure = c("tpr","auc"), x.measure = "fpr")
auc.methodPred  <- performance(methodPred, "auc")@y.values[[1]]
methodPred2  <- prediction(abs(c(tm2)), goldStandard)
roc.methodPred2  <- performance(methodPred2, measure = c("tpr","auc"), x.measure = "fpr")
auc.methodPred2  <- performance(methodPred2, "auc")@y.values[[1]]
p.value <- round(t.test(abs(c(tm))[goldStandard], abs(c(tm))[!goldStandard])$p.value,4)
if(p.value<2e-16){
p.value <- "p < 2e-16"
} else {
p.value <- paste0("p = ", p.value)
}
p.value2 <- round(t.test(abs(c(tm2))[goldStandard], abs(c(tm2))[!goldStandard])$p.value,4)
if(p.value2<2e-16){
p.value2 <- "p < 2e-16"
} else {
p.value2 <- paste0("p = ", p.value2)
}
plot(roc.methodPred, main=method, cex.main=2, col = 1, lwd=3)
lines(roc.methodPred2@x.values[[1]], roc.methodPred2@y.values[[1]], col = 2, lwd=3)
abline(0,1)
legend("bottomright", c(paste0("TM = ",round(auc.methodPred,4)," \n(",p.value,")\n"),paste0("EW = ",round(auc.methodPred2,4)," \n(",p.value2,")")),
lty=1,lwd=5,col=c(1,2), title="Area under the curve",cex=2)
}
# ROCforTransitions(tm.gs,method="Gold Standard")
png('simulation_transition_predictions.png', width=1800, height=1000)
par(mfrow=c(2,4),oma=c(0,0,4,0),cex.main = 4)
ROCforTransitions(tm.pearson, directTMcor, .5, method="Correlation Network")
ROCforTransitions(tm.wgcna6, directTMwgcna, .5, method="WGCNA (6)")
ROCforTransitions(tm.wgcna12, directTMwgcna12, .5, method="WGCNA (12)")
ROCforTransitions(tm.aracne, directTMaracne, .4, method="ARACNE")
ROCforTransitions(tm.clr, directTMclr, .5, method="CLR")
ROCforTransitions(tm.tom, directTMTOM, .5, method="TOM")
ROCforTransitions(tm.panda, directTMpanda, .5, method="PANDA")
ROCforTransitions(tm.bere, directbereRes, method="BERE")
title("ROC plots for recovering transitions", outer=TRUE)
dev.off()
# combinedGEXP <- cbind(gexpA, gexpB)
# combinedTFEXP <- cbind(tfExpA,tfExpB)
# null.networks <- lapply(1:1000, function(x){
#     groupA <- sample(1:(numSamples*2),numSamples)
#     res1 <- cor(t(combinedTFEXP[,groupA]), t(combinedGEXP[,groupA]))
#     res2 <- cor(t(combinedTFEXP[,-groupA]), t(combinedGEXP[,-groupA]))
#     list(res1,res2)
# })
# # Calculate the transformation matrix for the null data
# tm.null <- lapply(null.networks, function(x){
#     tm <- transformation.matrix(x[[1]],x[[2]],method="ols",remove.diagonal=T, standardize=F)
#     rownames(tm) <- TFNames
#     colnames(tm) <- TFNames
#     tm
# })
# rownames(tm.noisy) <- TFNames
# colnames(tm.noisy) <- TFNames
#
# ssodm.plot(tm.noisy, tm.null, rescale=T)
#
# ### penalized TM
# net1 <- t(pearsonAdjMatA)
# net2 <- t(pearsonAdjMatB)
# colFactor <- colSums(net1)/colSums(net2)
# net2.star <- net2-sweep(net1, 2, colFactor, '*')
# tm.pen <- sapply(1:numTFs, function(i){
#     z <- penalized(net1[,i], net2.star, lambda1=1, model="linear", standardize=T)
#     coefficients(z, "penalized")
# })
qplot(c(tm.bere), c(directbereRes))
summary(lm(c(tm.bere)~ c(directbereRes))
)
qplot(c(tm.bere), c(directbereRes))+geom_smooth(method='lm')
class(tm.bere)
class(directbereRes)
directbereRes[1:5,1:5]
tm.bere[1:5,1:5]
transformation.matrix
bereResA[1:5,1:5]
bereResB[1:5,1:5]
tm.bere      <- transformation.matrix(bereResA, bereResB, remove.diagonal=T, standardize=F, method="ols")
tm.bere[1:5,1:5]
dim(bereResA)
bereResA[1:5,1:5]
library(bptools)
transformation.matrix
detach("package:bptools", unload=TRUE)
library(bptools)
transformation.matrix
tm.bere      <- transformation.matrix(bereResA, bereResB, remove.diagonal=T, standardize=F, method="ols")
tm.bere
tm.gs        <- transformation.matrix(matrixA_GS, matrixB_GS, remove.diagonal=T, standardize=F, method="ols")
tm.pearson   <- transformation.matrix(pearsonAdjMatA, pearsonAdjMatB, remove.diagonal=T, standardize=F, method="ols")
tm.wgcna6    <- transformation.matrix(wgcnaA6, wgcnaB6, remove.diagonal=T, standardize=F, method="ols")
tm.wgcna12   <- transformation.matrix(wgcnaA12, wgcnaB12, remove.diagonal=T, standardize=F, method="ols")
tm.aracne    <- transformation.matrix(aracneA, aracneB, remove.diagonal=T, standardize=F, method="ols")
tm.clr       <- transformation.matrix(clrA, clrB, remove.diagonal=T, standardize=F, method="ols")
tm.tom       <- transformation.matrix(tomA, tomB, remove.diagonal=T, standardize=F, method="ols")
tm.panda     <- transformation.matrix(pandaResA, pandaResB, remove.diagonal=T, standardize=F, method="ols")
tm.bere      <- transformation.matrix(bereResA, bereResB, remove.diagonal=T, standardize=F, method="ols")
tm.gs
tm.pearson
tm.wgcna6
tm.wgcna12
tm.aracne
ROCforTransitions(tm.bere, directbereRes, method="BERE")
ROCforTransitions(tm.pearson, directTMcor, .5, method="Correlation Network")
ROCforTransitions(tm.wgcna6, directTMwgcna, .5, method="WGCNA (6)")
ROCforTransitions(tm.wgcna12, directTMwgcna12, .5, method="WGCNA (12)")
ROCforTransitions(tm.aracne, directTMaracne, .4, method="ARACNE")
ROCforTransitions(tm.clr, directTMclr, .5, method="CLR")
ROCforTransitions(tm.tom, directTMTOM, .5, method="TOM")
ROCforTransitions(tm.panda, directTMpanda, .5, method="PANDA")
ROCforTransitions(tm.bere, directbereRes, method="BERE")
tm.panda
ROCforTransitions(tm.panda, directTMpanda, .5, method="PANDA")
tm.bere      <- transformation.matrix(bereResA, bereResB, remove.diagonal=T, standardize=F, method="ols")
directbereRes
plotStrengthVsTransitionRank(tm.bere)
ROCforTransitions(tm.bere, directbereRes, method="BERE")
View(tomB)
tm.bere
heatmap.2(tm.bere, col=colorRampPalette(c("blue", "white", "red"))(n = 1000), density.info="none", trace="none", dendrogram="none", Colv=FALSE, Rowv=FALSE)
bereResA
bereAllA <- bere(motifsMelt, gexpAWithTFs, score="notincluded")#[TFNames,geneNames]
bereAllB <- bere(motifsMelt, gexpBWithTFs, score="notincluded")#[TFNames,geneNames]
bereAllA[1:5,1:5]
bereAllA <- bereAllA[TFNames,]
bereAllA
bereAllA[1:5,1:5]
bereAllB <- bereAllB[TFNames,]
bereResA <- bereAllA[,geneNames]
bereResB <- bereAllB[,geneNames]
bereAllA <- bere(motifsMelt, gexpAWithTFs, score="notincluded")#[TFNames,geneNames]
bereAllB <- bere(motifsMelt, gexpBWithTFs, score="notincluded")#[TFNames,geneNames]
bereAllA <- bereAllA[TFNames,c(TFNames,geneNames)]
bereAllB <- bereAllB[TFNames,c(TFNames,geneNames)]
bereAllA[1:5,1:5]
bereAllA[1:5,111:115]
dim(bereAllA)
bereResA <- bereAllA[,geneNames]
bereResB <- bereAllB[,geneNames]
pandaAllA <- panda(motifsMelt, gexpAWithTFs, hamming = 1e-02)@regNet
pandaAllB <- panda(motifsMelt, gexpBWithTFs, hamming = 1e-02)@regNet
pandaAllA[1:5,1:5]
pandaResA <- pandaAllA[,geneNames]
pandaResB <- pandaAllB[,geneNames]
corTFA <- mat2adj(t(tfExpA))
corTFB <- mat2adj(t(tfExpB))
directTMcor <- corTFA-corTFB
wgcnaTFA <- mat2adj(t(tfExpA), method="WGCNA")
wgcnaTFB <- mat2adj(t(tfExpB), method="WGCNA")
directTMwgcna <- wgcnaTFA-wgcnaTFB
tomTFA <- mat2adj(t(tfExpA), method="TOM")
tomTFB <- mat2adj(t(tfExpB), method="TOM")
directTMTOM <- tomTFA-tomTFB
wgcna12TFA <- mat2adj(t(tfExpA), method="WGCNA",P=12)
wgcna12TFB <- mat2adj(t(tfExpB), method="WGCNA",P=12)
directTMwgcna12 <- wgcna12TFA-wgcna12TFB
aracneTFA <- mat2adj(t(tfExpA), method="ARACNE")
aracneTFB <- mat2adj(t(tfExpB), method="ARACNE")
directTMaracne <- aracneTFA-aracneTFB
clrTFA <- mat2adj(t(tfExpA), method="CLR")
clrTFB <- mat2adj(t(tfExpB), method="CLR")
directTMclr <- clrTFA-clrTFB
directTMpanda <- pandaAllA[,-1:-numGenes]-pandaAllB[,-1:-numGenes]
directTMpanda <- directTMpanda[,rownames(directTMpanda)]
# Issue is here: Bere does not have TFs in results
directbereRes <- bereAllA[,TFNames]-bereAllB[,TFNames]
directbereRes <- directbereRes[TFNames,TFNames]
networkAUCROC <- function(netA, title=""){
methodPred  <- prediction(c(netA), c(matrixA_GS)>.5)
roc.methodPred  <- performance(methodPred, measure = c("tpr","auc"), x.measure = "fpr")
auc.methodPred  <- performance(methodPred, "auc")@y.values[[1]]
plot(roc.methodPred, main=title, col = 1, lwd=3)
p.value <- t.test(c(netA), c(matrixB_GS)>.5)$p.value
if(p.value<2e-16){
p.value <- "p < 2e-16"
} else {
p.value <- paste0("p = ", p.value)
}
abline(0,1)
legend("bottomright", paste0("AUC = ",round(auc.methodPred,4)," \n(",p.value,")"), lty=1,lwd=5,col=1, cex=2)
}
# getAUCROC <- function(netA){
#     methodPred  <- prediction(c(netA), c(matrixA_GS)>.5)
#     roc.methodPred  <- performance(methodPred, measure = c("tpr","auc"), x.measure = "fpr")
#     c(performance(methodPred, "auc")@y.values[[1]])
# }
png("simulated_network_roc.png", width=1800, height=1000)
par(mfrow=c(2,4),oma=c(0,0,4,0),cex.main = 4)
networkAUCROC(pearsonAdjMatA, "Correlation")
networkAUCROC(wgcnaA6, "WGCNA")
networkAUCROC(aracneA, "ARACNE")
networkAUCROC(clrA, "CLR")
networkAUCROC(tomA, "TOM")
networkAUCROC(motifs[,1:numGenes], "Motifs")
networkAUCROC(pandaResA, "PANDA")
networkAUCROC(bereResA, "BERE")
title("ROC plots for simulated networks", outer=TRUE)
dev.off()
# networkAUCROC(pandaResANULL, "PANDA NULL")
tm.gs        <- transformation.matrix(matrixA_GS, matrixB_GS, remove.diagonal=T, standardize=F, method="ols")
tm.pearson   <- transformation.matrix(pearsonAdjMatA, pearsonAdjMatB, remove.diagonal=T, standardize=F, method="ols")
tm.wgcna6    <- transformation.matrix(wgcnaA6, wgcnaB6, remove.diagonal=T, standardize=F, method="ols")
tm.wgcna12   <- transformation.matrix(wgcnaA12, wgcnaB12, remove.diagonal=T, standardize=F, method="ols")
tm.aracne    <- transformation.matrix(aracneA, aracneB, remove.diagonal=T, standardize=F, method="ols")
tm.clr       <- transformation.matrix(clrA, clrB, remove.diagonal=T, standardize=F, method="ols")
tm.tom       <- transformation.matrix(tomA, tomB, remove.diagonal=T, standardize=F, method="ols")
tm.panda     <- transformation.matrix(pandaResA, pandaResB, remove.diagonal=T, standardize=F, method="ols")
tm.bere      <- transformation.matrix(bereResA, bereResB, remove.diagonal=T, standardize=F, method="ols")
dim(pandaResA)
pandaResA[1:5,1:5]
dim(bereResA)
bereResA[1:5,1:5]
png('simulation_transition_predictions.png', width=1800, height=1000)
par(mfrow=c(2,4),oma=c(0,0,4,0),cex.main = 4)
ROCforTransitions(tm.pearson, directTMcor, .5, method="Correlation Network")
ROCforTransitions(tm.wgcna6, directTMwgcna, .5, method="WGCNA (6)")
ROCforTransitions(tm.wgcna12, directTMwgcna12, .5, method="WGCNA (12)")
ROCforTransitions(tm.aracne, directTMaracne, .4, method="ARACNE")
ROCforTransitions(tm.clr, directTMclr, .5, method="CLR")
ROCforTransitions(tm.tom, directTMTOM, .5, method="TOM")
ROCforTransitions(tm.panda, directTMpanda, .5, method="PANDA")
ROCforTransitions(tm.bere, directbereRes, method="BERE")
title("ROC plots for recovering transitions", outer=TRUE)
dev.off()
bereAllA[1:5,1:5]
dim(bereAllA)
bereAllB[1:5,1:5]
directbereRes
dim(bereAllA)
bereAllA[,TFNames]
networkAUCROC(bereResA, "BERE")
networkAUCROC(bereResA, bereResB, "BERE")
ROCforTransitions(tm.bere, directbereRes, method="BERE")
networkAUCROC(bereResA, "BERE")
networkAUCROC(matrixA_GS, "BERE")
tm.gs        <- transformation.matrix(matrixA_GS, matrixB_GS, remove.diagonal=T, standardize=F, method="ols")
tm.pearson   <- transformation.matrix(pearsonAdjMatA, pearsonAdjMatB, remove.diagonal=T, standardize=F, method="ols")
tm.wgcna6    <- transformation.matrix(wgcnaA6, wgcnaB6, remove.diagonal=T, standardize=F, method="ols")
tm.wgcna12   <- transformation.matrix(wgcnaA12, wgcnaB12, remove.diagonal=T, standardize=F, method="ols")
tm.aracne    <- transformation.matrix(aracneA, aracneB, remove.diagonal=T, standardize=F, method="ols")
tm.clr       <- transformation.matrix(clrA, clrB, remove.diagonal=T, standardize=F, method="ols")
tm.tom       <- transformation.matrix(tomA, tomB, remove.diagonal=T, standardize=F, method="ols")
tm.panda     <- transformation.matrix(pandaResA, pandaResB, remove.diagonal=T, standardize=F, method="ols")
tm.bere      <- transformation.matrix(bereResA, bereResB, remove.diagonal=T, standardize=F, method="ols")
ROCforTransitions(tm.pearson, directTMcor, .5, method="Correlation Network")
ROCforTransitions(tm.wgcna6, directTMwgcna, .5, method="WGCNA (6)")
ROCforTransitions(tm.wgcna12, directTMwgcna12, .5, method="WGCNA (12)")
ROCforTransitions(tm.aracne, directTMaracne, .4, method="ARACNE")
ROCforTransitions(tm.clr, directTMclr, .5, method="CLR")
ROCforTransitions(tm.tom, directTMTOM, .5, method="TOM")
ROCforTransitions(tm.panda, directTMpanda, .5, method="PANDA")
ROCforTransitions(tm.bere, directbereRes, method="BERE")
ROCforTransitions
ROCforTransitions(tm.bere, directbereRes, .5, method="BERE")
ROCforTransitions(tm.aracne, directTMaracne, .5, method="ARACNE")
ROCforTransitions(tm.clr, directTMclr, .5, method="CLR")
ROCforTransitions(tm.tom, directTMTOM, .5, method="TOM")
ROCforTransitions(tm.panda, directTMpanda, .5, method="PANDA")
ROCforTransitions(tm.bere, directbereRes, .5, method="BERE")
title("ROC plots for recovering transitions", outer=TRUE)
